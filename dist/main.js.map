{"version":3,"file":"main.js","mappings":"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","sources":["webpack://resumablejs/webpack/universalModuleDefinition","webpack://resumablejs/webpack/bootstrap","webpack://resumablejs/webpack/runtime/define property getters","webpack://resumablejs/webpack/runtime/hasOwnProperty shorthand","webpack://resumablejs/webpack/runtime/make namespace object","webpack://resumablejs/./src/resumableHelpers.ts","webpack://resumablejs/./src/resumableEventHandler.ts","webpack://resumablejs/./src/resumableChunk.ts","webpack://resumablejs/./src/resumableFile.ts","webpack://resumablejs/./src/resumable.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"resumablejs\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"resumablejs\"] = factory();\n\telse\n\t\troot[\"resumablejs\"] = factory();\n})(this, function() {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// INTERNAL HELPER METHODS (handy, but ultimately not part of uploading)\nimport {ExtendedFile} from \"./types/types\";\n\nexport default class ResumableHelpers {\n  /**\n   * Stop the propagation and default behavior of the given event `e`.\n   */\n  static stopEvent(e: Event): void {\n    e.stopPropagation();\n    e.preventDefault();\n  }\n\n  /**\n   * Generate a unique identifier for the given file based on its size, filename and relative path.\n   * @param {ExtendedFile} file The file for which the identifier should be generated\n   * @returns {string} The unique identifier for the given file object\n   */\n  static generateUniqueIdentifier(file: ExtendedFile): string {\n    let relativePath = file.webkitRelativePath || file.relativePath || file.name;\n    // The '/' is used to display the relative path of the file. This information should be preserved\n    relativePath = relativePath.replace('/', '-');\n    // Remove special characters\n    return (file.size + '-' + relativePath.replace(/[^0-9a-zA-Z_-]/img, ''));\n  }\n\n  /**\n   * Flatten the given array and all contained subarrays.\n   * Credit: {@link https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore#_flattendeep}\n   */\n  static flattenDeep(array: any[]): any[] {\n    return Array.isArray(array)\n      ? array.reduce((a, b) => a.concat(this.flattenDeep(b)), [])\n      : [array];\n  }\n\n  /**\n   * Filter the given array based on the predicate inside `callback`\n   * and executes `errorCallback` for duplicate elements.\n   */\n  static uniqBy(array: any[], callback: Function, errorCallback: Function): any[] {\n    let seen = new Set();\n    return array.filter((item) => {\n      let k = callback(item);\n      if (seen.has(k)) {\n        errorCallback(item);\n        return false;\n      } else {\n        seen.add(k);\n        return true;\n      }\n    });\n  }\n\n  /**\n   * Format the size given in Bytes in a human readable format.\n   */\n  static formatSize(size: number): string {\n    if (size < 1024) {\n      return size + ' bytes';\n    }\n    if (size < 1024 * 1024) {\n      return (size / 1024.0).toFixed(0) + ' KB';\n    }\n    if (size < 1024 * 1024 * 1024) {\n      return (size / 1024.0 / 1024.0).toFixed(1) + ' MB';\n    }\n    return (size / 1024.0 / 1024.0 / 1024.0).toFixed(1) + ' GB';\n  }\n\n  /**\n   * Use a polyfill for Object.assign if necessary.\n   * Credit: {@link https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#polyfill}\n   */\n  static assignObject(target: any, varArgs: any): any {\n    if (typeof Object.assign === 'function') {\n      return Object.assign(target, varArgs);\n    }\n    \n    if (target == null) { // TypeError if undefined or null\n      throw new TypeError('Cannot convert undefined or null to object');\n    }\n\n    const to = Object(target);\n\n    for (let index = 1; index < arguments.length; index++) {\n      const nextSource = arguments[index];\n\n      if (nextSource != null) { // Skip over if undefined or null\n        for (const nextKey in nextSource) {\n          // Avoid bugs when hasOwnProperty is shadowed\n          if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n            to[nextKey] = nextSource[nextKey];\n          }\n        }\n      }\n    }\n    return to;\n  }\n\n  /**\n   * Get the target url for the specified request type and params\n   */\n  static getTarget(\n    requestType: string,\n    sendTarget: string,\n    testTarget: string,\n    params: object,\n    parameterNamespace: string = ''\n  ) {\n    let target = sendTarget;\n\n    if (requestType === 'test' && testTarget) {\n      target = testTarget === '/' ? sendTarget : testTarget;\n    }\n\n    let separator = target.indexOf('?') < 0 ? '?' : '&';\n    let joinedParams = Object.entries(params).map(([key, value]) => [\n      encodeURIComponent(parameterNamespace + key),\n      encodeURIComponent(value),\n    ].join('=')).join('&');\n\n    if (joinedParams) target = target + separator + joinedParams;\n\n    return target;\n  }\n}\n","/**\n * The underlying base class for ResumableJS. This class is responsible for registering and executing\n * events and listeners.\n */\nexport default class ResumableEventHandler {\n  private registeredEventHandlers: { [event: string]: Function[]};\n\n  /**\n   * Construct a new event handler instance.\n   */\n  constructor() {\n    this.registeredEventHandlers = {};\n  }\n\n  /**\n   * Register a new callback for the given event.\n   */\n  on(event: string, callback: Function): void {\n    event = event.toLowerCase();\n    if (!this.registeredEventHandlers.hasOwnProperty(event)) {\n      this.registeredEventHandlers[event] = [];\n    }\n    this.registeredEventHandlers[event].push(callback);\n  }\n\n  /**\n   * Fire the event listeners for the given event with the given arguments as well as the wildcard event '*'\n   */\n  fire(event: string, ...args): void {\n    event = event.toLowerCase();\n\n    this.executeEventCallback(event, ...args);\n    this.executeEventCallback('*', event, ...args);\n  }\n\n  /**\n   * Execute all callbacks for the given event with the provided arguments. This function is only used internally\n   * to call all callbacks registered to a given event individually.\n   */\n  private executeEventCallback(event: string, ...args): void {\n    if (!this.registeredEventHandlers.hasOwnProperty(event)) return;\n    this.registeredEventHandlers[event].forEach((callback) => callback(...args));\n  }\n}\n","import Helpers from './resumableHelpers';\nimport ResumableEventHandler from './resumableEventHandler';\nimport ResumableFile from './resumableFile';\nimport {ResumableChunkStatus, ResumableConfiguration} from './types/types';\n\n/**\n * A file chunk that contains all the data that for a single upload request\n */\nexport default class ResumableChunk extends ResumableEventHandler {\n  private fileObj: ResumableFile;\n  private fileObjSize: number;\n  private fileObjType: string;\n  private offset: number;\n  private lastProgressCallback: Date = new Date;\n  private tested: boolean = false;\n  private retries: number = 0;\n  private pendingRetry: boolean = false;\n  private isMarkedComplete: boolean = false;\n  private loaded: number = 0;\n  private startByte: number;\n  private endByte: number;\n  private xhr: XMLHttpRequest = null;\n\n  // Option properties\n  private chunkSize: number = 1024 * 1024; // 1 MB\n  private forceChunkSize: boolean = false;\n  private fileParameterName: string = 'file';\n  chunkNumberParameterName: string = 'resumableChunkNumber';\n  chunkSizeParameterName: string = 'resumableChunkSize';\n  currentChunkSizeParameterName: string = 'resumableCurrentChunkSize';\n  totalSizeParameterName: string = 'resumableTotalSize';\n  typeParameterName: string = 'resumableType';\n  identifierParameterName: string = 'resumableIdentifier';\n  fileNameParameterName: string = 'resumableFilename';\n  relativePathParameterName: string = 'resumableRelativePath';\n  totalChunksParameterName: string = 'resumableTotalChunks';\n  throttleProgressCallbacks: number = 0.5;\n  query: object = {};\n  headers: object = {};\n  method: string = 'multipart';\n  uploadMethod: string = 'POST';\n  testMethod: string = 'GET';\n  parameterNamespace: string = '';\n  testChunks: boolean = true;\n  maxChunkRetries: number = 100;\n  chunkRetryInterval?: number = undefined;\n  permanentErrors: number[] = [400, 401, 403, 404, 409, 415, 500, 501];\n  withCredentials: boolean = false;\n  xhrTimeout: number = 0;\n  chunkFormat: string = 'blob';\n  setChunkTypeFromFile: boolean = false;\n  target: string = '/';\n  testTarget: string = '';\n\n\n  constructor(fileObj: ResumableFile, offset: number, options: ResumableConfiguration) {\n    super();\n    this.setInstanceProperties(options);\n    this.fileObj = fileObj;\n    this.fileObjSize = fileObj.size;\n    this.fileObjType = fileObj.file.type;\n    this.offset = offset;\n\n    // Computed properties\n    this.startByte = this.offset * this.chunkSize;\n    this.endByte = Math.min(this.fileObjSize, (this.offset + 1) * this.chunkSize);\n    if (this.fileObjSize - this.endByte < this.chunkSize && !this.forceChunkSize) {\n      // The last chunk will be bigger than the chunk size, but less than 2*chunkSize\n      this.endByte = this.fileObjSize;\n    }\n    this.xhr = null;\n  }\n\n  /**\n   * Set the options provided inside the configuration object on this instance\n   */\n  protected setInstanceProperties(options: ResumableConfiguration): void {\n    Helpers.assignObject(this, options);\n  }\n\n  /**\n   * Set the header values for the current XMLHttpRequest\n   */\n  setCustomHeaders(): void {\n    if (!this.xhr) {\n      return;\n    }\n    let customHeaders = this.headers;\n    if (customHeaders instanceof Function) {\n      customHeaders = customHeaders(this.fileObj, this);\n    }\n    for (const header in customHeaders) {\n      if (!customHeaders.hasOwnProperty(header)) continue;\n      this.xhr.setRequestHeader(header, customHeaders[header]);\n    }\n  }\n\n  /**\n   * Get query parameters for this chunk as an object, combined with custom parameters if provided\n   */\n  get formattedQuery(): object {\n    var customQuery = this.query;\n    if (typeof customQuery == 'function') customQuery = customQuery(this.fileObj, this);\n\n    // Add extra data to identify chunk\n    const extraData = {\n      // define key/value pairs for additional parameters\n      [this.chunkNumberParameterName]: this.offset + 1,\n      [this.chunkSizeParameterName]: this.chunkSize,\n      [this.currentChunkSizeParameterName]: this.endByte - this.startByte,\n      [this.totalSizeParameterName]: this.fileObjSize,\n      [this.typeParameterName]: this.fileObjType,\n      [this.identifierParameterName]: this.fileObj.uniqueIdentifier,\n      [this.fileNameParameterName]: this.fileObj.fileName,\n      [this.relativePathParameterName]: this.fileObj.relativePath,\n      [this.totalChunksParameterName]: this.fileObj.chunks.length,\n    };\n    return {...extraData, ...customQuery};\n  }\n\n  /**\n   * Determine the status for this Chunk based on different parameters of the underlying XMLHttpRequest\n   */\n  get status(): ResumableChunkStatus {\n    if (this.pendingRetry) {\n      // if pending retry then that's effectively the same as actively uploading,\n      // there might just be a slight delay before the retry starts\n      return ResumableChunkStatus.UPLOADING;\n    } else if (this.isMarkedComplete) {\n      return ResumableChunkStatus.SUCCESS;\n    } else if (!this.xhr) {\n      return ResumableChunkStatus.PENDING;\n    } else if (this.xhr.readyState < 4) {\n      // Status is really 'OPENED', 'HEADERS_RECEIVED' or 'LOADING' - meaning that stuff is happening\n      return ResumableChunkStatus.UPLOADING;\n    } else if (this.xhr.status === 200 || this.xhr.status === 201) {\n      // HTTP 200, 201 (created)\n      return ResumableChunkStatus.SUCCESS;\n    } else if (this.permanentErrors.includes(this.xhr.status) || this.retries >= this.maxChunkRetries) {\n      // HTTP 400, 404, 409, 415, 500, 501 (permanent error)\n      return ResumableChunkStatus.ERROR;\n    } else {\n      // this should never happen, but we'll reset and queue a retry\n      // a likely case for this would be 503 service unavailable\n      this.abort();\n      return ResumableChunkStatus.PENDING;\n    }\n  };\n\n  /**\n   * Get the target url for the specified request type and the configured parameters of this chunk\n   * @param requestType The type of the request, either 'test' or 'upload'\n   */\n  getTarget(requestType: string): string {\n    return Helpers.getTarget(requestType, this.target, this.testTarget, this.formattedQuery, this.parameterNamespace);\n  }\n\n  /**\n   * Makes a GET request without any data to see if the chunk has already been uploaded in a previous session\n   */\n  test(): void {\n    // Set up request and listen for event\n    this.xhr = new XMLHttpRequest();\n\n    var testHandler = () => {\n      this.tested = true;\n      var status = this.status;\n      if (status === ResumableChunkStatus.SUCCESS) {\n        this.fire('chunkSuccess', this.message());\n      } else {\n        this.send();\n      }\n    };\n    this.xhr.addEventListener('load', testHandler, false);\n    this.xhr.addEventListener('error', testHandler, false);\n    this.xhr.addEventListener('timeout', testHandler, false);\n\n    // Append the relevant chunk and send it\n    this.xhr.open(this.testMethod, this.getTarget('test'));\n    this.xhr.timeout = this.xhrTimeout;\n    this.xhr.withCredentials = this.withCredentials;\n    // Add data from header options\n    this.setCustomHeaders();\n\n    this.xhr.send(null);\n  }\n\n  /**\n   * Abort and reset a request\n   */\n  abort(): void {\n    if (this.xhr) this.xhr.abort();\n    this.xhr = null;\n  }\n\n  /**\n   *  Uploads the actual data in a POST call\n   */\n  send(): void {\n    if (this.testChunks && !this.tested) {\n      this.test();\n      return;\n    }\n\n    // Set up request and listen for event\n    this.xhr = new XMLHttpRequest();\n\n    // Progress\n    this.xhr.upload.addEventListener('progress', (e: ProgressEvent<XMLHttpRequestEventTarget>) => {\n      if (Date.now() - this.lastProgressCallback.getTime() > this.throttleProgressCallbacks * 1000) {\n        this.fire('chunkProgress');\n        this.lastProgressCallback = new Date();\n      }\n      this.loaded = e.loaded || 0;\n    }, false);\n    this.loaded = 0;\n    this.pendingRetry = false;\n    this.fire('chunkProgress');\n\n    /**\n     * Handles the different xhr registeredEventHandlers based on the status of this chunk\n     */\n    let doneHandler = () => {\n      var status = this.status;\n      switch (status) {\n        case ResumableChunkStatus.SUCCESS:\n        case ResumableChunkStatus.ERROR:\n          this.fire(status, this.message());\n          break;\n        default:\n          this.fire('chunkRetry', this.message());\n          this.abort();\n          this.retries++;\n          let retryInterval = this.chunkRetryInterval;\n          if (retryInterval !== undefined) {\n            this.pendingRetry = true;\n            setTimeout(this.send, retryInterval);\n          } else {\n            this.send();\n          }\n          break;\n      }\n    };\n    this.xhr.addEventListener('load', doneHandler, false);\n    this.xhr.addEventListener('error', doneHandler, false);\n    this.xhr.addEventListener('timeout', doneHandler, false);\n\n    // Set up the basic query data from Resumable\n    let bytes = this.fileObj.file.slice(this.startByte, this.endByte,\n      this.setChunkTypeFromFile ? this.fileObj.file.type : '');\n    let data = null;\n    let parameterNamespace = this.parameterNamespace;\n    // Add data from the query options\n    if (this.method === 'octet') {\n      data = bytes;\n    } else {\n      data = new FormData();\n      for (const queryKey in this.formattedQuery) {\n        data.append(parameterNamespace + queryKey, this.formattedQuery[queryKey]);\n      }\n      switch (this.chunkFormat) {\n        case 'blob':\n          data.append(parameterNamespace + this.fileParameterName, bytes, this.fileObj.fileName);\n          break;\n        case 'base64':\n          var fr = new FileReader();\n          fr.onload = () => {\n            data.append(parameterNamespace + this.fileParameterName, fr.result);\n            this.xhr.send(data);\n          };\n          fr.readAsDataURL(bytes);\n          break;\n      }\n    }\n\n    let target = this.getTarget('upload');\n\n    this.xhr.open(this.uploadMethod, target);\n    if (this.method === 'octet') {\n      this.xhr.setRequestHeader('Content-Type', 'application/octet-stream');\n    }\n    this.xhr.timeout = this.xhrTimeout;\n    this.xhr.withCredentials = this.withCredentials;\n    // Add data from header options\n    this.setCustomHeaders();\n\n    if (this.chunkFormat === 'blob') {\n      this.xhr.send(data);\n    }\n  }\n\n  /**\n   * Return the response text of the underlying XMLHttpRequest if it exists\n   */\n  message(): string {\n    return this.xhr ? this.xhr.responseText : '';\n  };\n\n  /**\n   * Return the progress for the current chunk as a number between 0 and 1\n   * @param relative Whether or not the progress should be calculated based on the size of the entire file\n   */\n  progress(relative: boolean = false): number {\n    var factor = relative ? (this.endByte - this.startByte) / this.fileObjSize : 1;\n    if (this.pendingRetry) return 0;\n    if ((!this.xhr || !this.xhr.status) && !this.isMarkedComplete) factor *= .95;\n    switch (this.status) {\n      case ResumableChunkStatus.SUCCESS:\n      case ResumableChunkStatus.ERROR:\n        return factor;\n      case ResumableChunkStatus.PENDING:\n        return 0;\n      default:\n        return this.loaded / (this.endByte - this.startByte) * factor;\n    }\n  }\n\n  /**\n   * Mark this chunk as completed because it was already uploaded to the server.\n   */\n  markComplete(): void {\n    this.isMarkedComplete = true;\n  }\n}\n","import ResumableChunk from './resumableChunk';\nimport Helpers from './resumableHelpers';\nimport ResumableEventHandler from './resumableEventHandler';\nimport {ResumableChunkStatus, ResumableConfiguration} from './types/types';\n\n/**\n * A single file object that should be uploaded in multiple chunks\n */\nexport default class ResumableFile extends ResumableEventHandler {\n  private opts: ResumableConfiguration;\n  private _prevProgress: number = 0;\n  private isPaused: boolean = false;\n\n  file: File;\n  fileName: string;\n  size: number;\n  relativePath: string;\n  uniqueIdentifier: string;\n  private _error: boolean;\n  chunks: ResumableChunk[] = [];\n  private chunkSize: number = 1024 * 1024; // 1 MB\n  private forceChunkSize: boolean = false;\n\n  constructor(file: File, uniqueIdentifier: string, options: object) {\n    super();\n    this.opts = options;\n    this.setInstanceProperties(options);\n    this.file = file;\n    this.fileName = file.name;\n    this.size = file.size;\n    this.relativePath = /*file.relativePath ||*/ file.webkitRelativePath || this.fileName;\n    this.uniqueIdentifier = uniqueIdentifier;\n    this._error = uniqueIdentifier !== undefined;\n\n    // Bootstrap file\n    this.fire('chunkingStart', this);\n    this.bootstrap();\n  }\n\n  /**\n   * Set the options provided inside the configuration object on this instance\n   */\n  protected setInstanceProperties(options: ResumableConfiguration) {\n    Helpers.assignObject(this, options);\n  }\n\n  /**\n   * Stop current uploads for this file\n   */\n  abort(): void {\n    let abortCount = 0;\n    for (const chunk of this.chunks) {\n      if (chunk.status === ResumableChunkStatus.UPLOADING) {\n        chunk.abort();\n        abortCount++;\n      }\n    }\n    if (abortCount > 0) this.fire('fileProgress', this);\n  }\n\n  /**\n   * Cancel uploading this file and remove it from the file list\n   */\n  cancel(): void {\n    for (const chunk of this.chunks) {\n      if (chunk.status === ResumableChunkStatus.UPLOADING) {\n        chunk.abort();\n        this.fire('chunkCancel', chunk);\n      }\n    }\n    // Reset this file to be void\n    this.chunks = [];\n    this.fire('fileCancel', this);\n    this.fire('fileProgress', this);\n  }\n\n  /**\n   * Retry uploading this file\n   */\n  retry(): void {\n    this.bootstrap();\n    let firedRetry = false;\n    this.on('chunkingComplete', () => {\n      if (!firedRetry) this.fire('fileRetry');\n      firedRetry = true;\n    });\n  }\n\n  /**\n   * Prepare this file for a new upload, by dividing it into multiple chunks\n   */\n  bootstrap(): void {\n    const progressHandler = (message) => this.fire('fileProgress', this, message);\n    const retryHandler = () =>  this.fire('fileRetry', this);\n    const successHandler = (message) => {\n      if (this._error) return;\n      this.fire('chunkSuccess');\n      this.fire('fileProgress', this, message); // it's at least progress\n      if (this.isComplete) {\n        this.fire('fileSuccess', this, message);\n      }\n    };\n    const errorHandler = (message) => {\n      this.fire('chunkError', message);\n      this.abort();\n      this._error = true;\n      this.chunks = [];\n      this.fire('fileError', this, message);\n    }\n\n    this.abort();\n    this._error = false;\n    // Rebuild stack of chunks from file\n    this.chunks = [];\n    this._prevProgress = 0;\n    const round = this.forceChunkSize ? Math.ceil : Math.floor;\n    const maxOffset = Math.max(round(this.file.size / this.chunkSize), 1);\n    for (var offset = 0; offset < maxOffset; offset++) {\n      const chunk = new ResumableChunk(this, offset, this.opts);\n      chunk.on('chunkProgress', progressHandler);\n      chunk.on('chunkError', errorHandler);\n      chunk.on('chunkSuccess', successHandler);\n      chunk.on('chunkRetry', retryHandler);\n      this.chunks.push(chunk);\n      this.fire('chunkingProgress', this, offset / maxOffset);\n    }\n    this.fire('chunkingComplete', this);\n  }\n\n  /**\n   * Get the progress for uploading this file based on the progress of the individual file chunks\n   */\n  progress(): number {\n    if (this._error) return 1;\n    // Sum up progress across everything\n    var ret = 0;\n    var error = false;\n    for (const chunk of this.chunks) {\n      if (chunk.status === ResumableChunkStatus.ERROR) error = true;\n      ret += chunk.progress(true); // get chunk progress relative to entire file\n    }\n    ret = error ? 1 : (ret > 0.99999 ? 1 : ret);\n    ret = Math.max(this._prevProgress, ret); // We don't want to lose percentages when an upload is paused\n    this._prevProgress = ret;\n    return ret;\n  }\n\n  /**\n   * Check whether at least one of this file's chunks is currently uploading\n   */\n  get isUploading(): boolean {\n    return this.chunks.some((chunk) => chunk.status === ResumableChunkStatus.UPLOADING);\n  }\n\n  /**\n   * Check whether all of this file's chunks completed their upload requests and whether it should be\n   * treated as completed.\n   */\n  get isComplete(): boolean {\n    return !this.chunks.some((chunk) =>\n      chunk.status === ResumableChunkStatus.PENDING || chunk.status === ResumableChunkStatus.UPLOADING);\n  }\n\n  /**\n   * Initiate the upload of a new chunk for this file. This function returns whether a new upload was started or not.\n   */\n  upload(): boolean {\n    if (this.isPaused) {\n      return false;\n    }\n\n    for (const chunk of this.chunks) {\n      if (chunk.status === ResumableChunkStatus.PENDING) {\n        chunk.send();\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Mark a given number of chunks as already uploaded to the server.\n   * @param chunkNumber The index until which all chunks should be marked as completed\n   */\n  markChunksCompleted(chunkNumber: number): void {\n    if (!this.chunks || this.chunks.length <= chunkNumber) {\n      return;\n    }\n    for (let num = 0; num < chunkNumber; num++) {\n      this.chunks[num].markComplete();\n    }\n  }\n}\n","import Helpers from './resumableHelpers';\nimport ResumableFile from './resumableFile';\nimport ResumableEventHandler from './resumableEventHandler';\nimport {ExtendedFile, ResumableChunkStatus, ResumableConfiguration} from './types/types';\n\n/*\n* MIT Licensed\n* http://www.twentythree.com/\n* http://github.com/23/resumable.js\n* Steffen Tiedemann Christensen, steffen@twentythree.com\n*/\n\n/**\n * An instance of a resumable upload handler that contains one or multiple files which should be uploaded in chunks.\n */\nexport class Resumable extends ResumableEventHandler {\n  private opts: ResumableConfiguration;\n  private files: ResumableFile[] = [];\n  private validators: {[fileType: string]: Function} = {};\n  private support: boolean;\n\n  // Configuration Options\n  clearInput: boolean = true;\n  dragOverClass: string = 'dragover';\n  fileTypes: string[] = [];\n  fileTypeErrorCallback: Function = (file) => {\n    alert(`${file.fileName || file.name} has an unsupported file type, please upload files of type ${this.fileTypes}.`);\n  };\n  _generateUniqueIdentifier: Function = null;\n  maxFileSize?: number;\n  maxFileSizeErrorCallback: Function = (file) => {\n    alert(file.fileName || file.name + ' is too large, please upload files less than ' +\n      Helpers.formatSize(this.maxFileSize) + '.');\n  };\n  maxFiles?: number;\n  maxFilesErrorCallback: Function = (files) => {\n    var maxFiles = this.maxFiles;\n    alert('Please upload no more than ' + maxFiles + ' file' + (maxFiles === 1 ? '' : 's') + ' at a time.');\n  };\n  minFileSize: number = 1;\n  minFileSizeErrorCallback: Function = (file) => {\n    alert(file.fileName || file.name + ' is too small, please upload files larger than ' +\n      Helpers.formatSize(this.minFileSize) + '.');\n  };\n  prioritizeFirstAndLastChunk: boolean = false;\n  fileValidationErrorCallback: Function = (file) => {};\n  simultaneousUploads: number = 3;\n\n  constructor(options: ResumableConfiguration = {}) {\n    super();\n    this.setInstanceProperties(options);\n    this.opts = options;\n    this.checkSupport();\n  }\n\n  /**\n   * Check whether the current browser supports the essential functions for the package to work.\n   * The method checks if these features are supported:\n   * - File object type\n   * - Blob object type\n   * - FileList object type\n   * - slicing files\n   */\n  private checkSupport(): void {\n    this.support =\n      File !== undefined &&\n      Blob !== undefined &&\n      FileList !== undefined &&\n      !!Blob.prototype.slice;\n    if (!this.support) {\n      throw new Error('Not supported by Browser');\n    }\n  }\n\n  /**\n   * Assign the attributes of this instance via destructuring of the options object.\n   */\n  protected setInstanceProperties(options: ResumableConfiguration) {\n    Helpers.assignObject(this, options);\n\n    // For good behaviour we do some initial sanitizing. Remove spaces and dots and lowercase all\n    this.fileTypes = this.fileTypes.map((type) => type.replace(/[\\s.]/g, '').toLowerCase());\n  }\n\n  /**\n   * Transforms a single fileEntry or directoryEntry item into a list of File objects this method is used to convert\n   * entries found inside dragged-and-dropped directories.\n   * @param {Object} item item to upload, may be file or directory entry\n   * @param {string} path current file path\n   */\n  private async mapDirectoryItemToFile(item: FileSystemEntry, path: string): Promise<File[]> {\n    if (item.isFile) {\n      // file entry provided\n      const file = await new Promise(\n        (resolve, reject) => (item as FileSystemFileEntry).file(resolve, reject)\n      ) as ExtendedFile;\n      file.relativePath = path + file.name;\n      return [file];\n    } else if (item.isDirectory) {\n      // directory entry provided\n      return await this.processDirectory(item as FileSystemDirectoryEntry, path + item.name + '/');\n    } else if (item instanceof File) {\n      return [item];\n    }\n\n    console.warn('Item mapping did not return a file object. This might be due to an unknown file type.')\n    return [];\n  }\n\n  /**\n   * Transforms a single DataTransfer item into a File object. This may include either extracting the given file or\n   * all files inside the provided directory.\n   * @param item item to upload, may be file or directory entry\n   * @param path current file path\n   */\n  private async mapDragItemToFile(item: DataTransferItem, path: string): Promise<File[]> {\n    let entry = item.webkitGetAsEntry();\n    if (entry.isDirectory) {\n      return await this.processDirectory(entry as FileSystemDirectoryEntry, path + entry.name + '/');\n    }\n\n    let file = item.getAsFile();\n    if (file instanceof File) {\n      (file as ExtendedFile).relativePath = path + file.name;\n      return [file];\n    }\n\n    console.warn('Item mapping did not return a file object. This might be due to an unknown file type.')\n    return [];\n  }\n\n  /**\n   * Recursively traverse a directory and collect files to upload\n   */\n  private processDirectory(directory: FileSystemDirectoryEntry, path: string): Promise<File[]> {\n    return new Promise((resolve, reject) => {\n      const dirReader = directory.createReader();\n      let allEntries = [];\n\n      const readEntries = (): void => {\n        dirReader.readEntries(async (entries: FileSystemEntry[]): Promise<void> => {\n          // Read the files batch-wise (in chrome e.g. 100 at a time)\n          if (entries.length) {\n            allEntries = allEntries.concat(entries);\n            return readEntries();\n          }\n\n          // After collecting all files, map all fileEntries to File objects\n          allEntries = allEntries.map((entry) => {\n            return this.mapDirectoryItemToFile(entry, path);\n          });\n          // Wait until all files are collected.\n          resolve(await Promise.all(allEntries));\n        }, reject);\n      };\n\n      readEntries();\n    });\n  }\n\n  /**\n   * Handle the event when a new file was provided via drag-and-drop\n   */\n  private async onDrop(e: DragEvent): Promise<void> {\n    (e.currentTarget as HTMLElement).classList.remove(this.dragOverClass);\n    Helpers.stopEvent(e);\n\n    let items = [];\n\n    //handle dropped things as items if we can (this lets us deal with folders nicer in some cases)\n    if (e.dataTransfer && e.dataTransfer.items) {\n      items = Array.from(e.dataTransfer.items);\n    }\n    //else handle them as files\n    else if (e.dataTransfer && e.dataTransfer.files) {\n      items = Array.from(e.dataTransfer.files);\n    }\n\n    if (!items.length) {\n      return; // nothing to do\n    }\n    this.fire('fileProcessingBegin', items);\n    let promises = items.map((item) => this.mapDragItemToFile(item, ''));\n    let files = Helpers.flattenDeep(await Promise.all(promises));\n    if (files.length) {\n      // at least one file found\n      this.appendFilesFromFileList(files, e);\n    }\n  }\n\n  /**\n   * Handle the event when a drag-and-drop item leaves the area of assigned drag-and-drop area\n   */\n  private onDragLeave(e: DragEvent): void {\n    (e.currentTarget as HTMLElement).classList.remove(this.dragOverClass);\n  }\n\n  /**\n   * Handle the event when a drag-and-drop item enters the area of assigned drag-and-drop area\n   */\n  private onDragOverEnter(e: DragEvent): void {\n    e.preventDefault();\n    let dt = e.dataTransfer;\n    if (dt.types.includes('Files')) { // only for file drop\n      e.stopPropagation();\n      dt.dropEffect = 'copy';\n      dt.effectAllowed = 'copy';\n      (e.currentTarget as HTMLElement).classList.add(this.dragOverClass);\n    } else {\n      dt.dropEffect = 'none';\n      dt.effectAllowed = 'none';\n    }\n  };\n\n  /**\n   * Validate and clean a list of files. This includes the removal of duplicates, a check whether the file type is\n   * allowed and custom validation functions defined per file type.\n   * @param {ExtendedFile[]} files A list of File instances that were previously extended with a uniqueIdentifier\n   */\n  private async validateFiles(files: ExtendedFile[]): Promise<ExtendedFile[]> {\n    // Remove files that are duplicated in the original array, based on their unique identifiers\n    let uniqueFiles = Helpers.uniqBy(files,\n      (file) => file.uniqueIdentifier,\n      (file) => this.fire('fileProcessingFailed', file, 'duplicate'),\n    );\n\n    let validationPromises = uniqueFiles.map(async (file) => {\n      // Remove files that were already added based on their unique identifiers\n      if (this.files.some((addedFile) => addedFile.uniqueIdentifier === file.uniqueIdentifier)) {\n        this.fire('fileProcessingFailed', file, 'duplicate');\n        return false;\n      }\n\n      let fileType: string = file.type.toLowerCase();\n      let fileExtension = file.name.split('.').pop().toLowerCase();\n\n      if (this.fileTypes.length > 0) {\n        const fileTypeFound = this.fileTypes.some((type) => {\n          // Check whether the extension inside the filename is an allowed file type\n          return fileExtension === type ||\n            // If MIME type, check for wildcard or if extension matches the file's tile type\n            type.includes('/') && (\n              type.includes('*') &&\n              fileType.substring(0, type.indexOf('*')) === type.substring(0, type.indexOf('*')) ||\n              fileType === type\n            );\n        });\n        if (!fileTypeFound) {\n          this.fire('fileProcessingFailed', file, 'fileType');\n          this.fileTypeErrorCallback(file);\n          return false;\n        }\n      }\n\n      // Validate the file size against minimum and maximum allowed sizes\n      if (this.minFileSize !== undefined && file.size < this.minFileSize) {\n        this.fire('fileProcessingFailed', file, 'minFileSize');\n        this.minFileSizeErrorCallback(file);\n        return false;\n      }\n      if (this.maxFileSize !== undefined && file.size > this.maxFileSize) {\n        this.fire('fileProcessingFailed', file, 'maxFileSize');\n        this.maxFileSizeErrorCallback(file);\n        return false;\n      }\n\n      // Apply a custom validator based on the file extension\n      if (fileExtension in this.validators && !await this.validators[fileExtension](file)) {\n        this.fire('fileProcessingFailed', file, 'validation');\n        this.fileValidationErrorCallback(file);\n        return false;\n      }\n\n      return true;\n    });\n\n    const results = await Promise.all(validationPromises);\n\n    // Only include files that passed their validation tests\n    return files.filter((_v, index) => results[index]);\n  }\n\n  /**\n   * Add an array of files to this instance's file list by creating new ResumableFiles. This includes a validation and\n   * deduplication of the provided array.\n   * @param fileList An array containing File objects\n   * @param event The event with which the fileList was provided\n   */\n  private async appendFilesFromFileList(fileList: File[], event: Event): Promise<boolean> {\n    // check for uploading too many files\n    if (this.maxFiles !== undefined && this.maxFiles < fileList.length + this.files.length) {\n      // if single-file upload, file is already added, and trying to add 1 new file, simply replace the already-added file\n      if (this.maxFiles === 1 && this.files.length === 1 && fileList.length === 1) {\n        this.removeFile(this.files[0]);\n      } else {\n        this.fire('fileProcessingFailed', undefined, 'maxFiles');\n        this.maxFilesErrorCallback(fileList);\n        return false;\n      }\n    }\n\n    // Add the unique identifier for every new file.\n    // Since this might return a promise, we have to wait until it completed.\n    const filesWithUniqueIdentifiers = await Promise.all(fileList.map(async (file: ExtendedFile): Promise<ExtendedFile> => {\n      file.uniqueIdentifier = await this.generateUniqueIdentifier(file, event);\n      return file;\n    }));\n\n    // Validate the files and remove duplicates\n    const validatedFiles = await this.validateFiles(filesWithUniqueIdentifiers);\n\n    let skippedFiles = filesWithUniqueIdentifiers.filter((file) => !validatedFiles.includes(file));\n\n    for (const file of validatedFiles) {\n      let f = new ResumableFile(file, file.uniqueIdentifier, this.opts);\n      f.on('chunkSuccess', () => this.handleChunkSuccess());\n      f.on('chunkError', () => this.handleChunkError());\n      f.on('chunkCancel', () => this.handleChunkCancel());\n      f.on('fileProgress', () => this.handleFileProgress());\n      f.on('fileError', (...args) => this.handleFileError(args));\n      f.on('fileSuccess', (...args) => this.handleFileSuccess(args));\n      f.on('fileCancel', (...args) => this.handleFileCancel(args));\n      f.on('fileRetry', () => this.handleFileRetry());\n      this.files.push(f);\n      this.fire('fileAdded', f, event);\n    }\n\n    // all files processed, trigger event\n    if (!validatedFiles.length && !skippedFiles.length) {\n      // no succeeded files, just skip\n      return;\n    }\n    this.fire('filesAdded', validatedFiles, skippedFiles);\n  }\n\n  /**\n   * Generate a new unique identifier for a given file either with a default helper function or with a custom\n   * generator function.\n   * @param file The file as an HTML 5 File object\n   * @param event The event with which the file was provided originally\n   */\n  private generateUniqueIdentifier(file: File, event: Event): string {\n    return typeof this._generateUniqueIdentifier === 'function' ?\n      this._generateUniqueIdentifier(file, event) : Helpers.generateUniqueIdentifier(file);\n  }\n\n  /**\n   * Queue a new chunk to be uploaded that is currently awaiting upload.\n   */\n  private uploadNextChunk(): void {\n    // In some cases (such as videos) it's really handy to upload the first\n    // and last chunk of a file quickly; this lets the server check the file's\n    // metadata and determine if there's even a point in continuing.\n    if (this.prioritizeFirstAndLastChunk) {\n      for (const file of this.files) {\n        if (file.chunks.length && file.chunks[0].status === ResumableChunkStatus.PENDING) {\n          file.chunks[0].send();\n          return;\n        }\n        if (file.chunks.length > 1 && file.chunks[file.chunks.length - 1].status === ResumableChunkStatus.PENDING) {\n          file.chunks[file.chunks.length - 1].send();\n          return;\n        }\n      }\n    }\n\n    // Now, simply look for the next best thing to upload\n    for (const file of this.files) {\n      if (file.upload()) return;\n    }\n  }\n\n  /**\n   *  PUBLIC METHODS FOR RESUMABLE.JS\n   *  This section only includes methods that should be callable from external packages.\n   */\n\n  /**\n   * Assign a browse action to one or more DOM nodes. Pass in true to allow directories to be selected (Chrome only).\n   */\n  assignBrowse(domNodes: HTMLElement | HTMLElement[], isDirectory: boolean = false): void {\n    if (domNodes instanceof HTMLElement) domNodes = [domNodes];\n    for (const domNode of domNodes) {\n      let input;\n      if (domNode instanceof HTMLInputElement && domNode.type === 'file') {\n        input = domNode;\n      } else {\n        input = document.createElement('input');\n        input.setAttribute('type', 'file');\n        input.style.display = 'none';\n        domNode.addEventListener('click', () => {\n          input.style.opacity = 0;\n          input.style.display = 'block';\n          input.focus();\n          input.click();\n          input.style.display = 'none';\n        }, false);\n        domNode.appendChild(input);\n      }\n      if (this.maxFiles !== 1) {\n        input.setAttribute('multiple', 'multiple');\n      } else {\n        input.removeAttribute('multiple');\n      }\n      if (isDirectory) {\n        input.setAttribute('webkitdirectory', 'webkitdirectory');\n      } else {\n        input.removeAttribute('webkitdirectory');\n      }\n      if (this.fileTypes.length >= 1) {\n        input.setAttribute('accept', this.fileTypes.map((type) => {\n          type = type.replace(/\\s/g, '').toLowerCase();\n          if (type.match(/^[^.][^/]+$/)) {\n            type = '.' + type;\n          }\n          return type;\n        }).join(','));\n      } else {\n        input.removeAttribute('accept');\n      }\n      // When new files are added, simply append them to the overall list\n      input.addEventListener('change', (e: InputEvent) => {\n        const eventTarget = e.target as HTMLInputElement;\n        this.fire('fileProcessingBegin', eventTarget.files);\n        this.appendFilesFromFileList(Array.from(eventTarget.files), e);\n        if (this.clearInput) {\n          eventTarget.value = '';\n        }\n      }, false);\n    }\n  }\n\n  /**\n   * Assign one or more DOM nodes as a drop target.\n   */\n  assignDrop(domNodes: HTMLElement | HTMLElement[]): void {\n    if (domNodes instanceof HTMLElement) domNodes = [domNodes];\n\n    for (const domNode of domNodes) {\n      domNode.addEventListener('dragover', this.onDragOverEnter.bind(this), false);\n      domNode.addEventListener('dragenter', this.onDragOverEnter.bind(this), false);\n      domNode.addEventListener('dragleave', this.onDragLeave.bind(this), false);\n      domNode.addEventListener('drop', this.onDrop.bind(this), false);\n    }\n  }\n\n  /**\n   * Remove one or more DOM nodes as a drop target.\n   */\n  unAssignDrop(domNodes: HTMLElement | HTMLElement[]): void {\n    if (domNodes instanceof HTMLElement) domNodes = [domNodes];\n\n    for (const domNode of domNodes) {\n      domNode.removeEventListener('dragover', this.onDragOverEnter.bind(this));\n      domNode.removeEventListener('dragenter', this.onDragOverEnter.bind(this));\n      domNode.removeEventListener('dragleave', this.onDragLeave.bind(this));\n      domNode.removeEventListener('drop', this.onDrop.bind(this));\n    }\n  }\n\n  /**\n   * Check whether any files are currently uploading\n   */\n  get isUploading(): boolean {\n    return this.files.some((file) => file.isUploading);\n  }\n\n  /**\n   * Start or resume the upload of the provided files by initiating the upload of the first chunk\n   */\n  upload(): void {\n    // Make sure we don't start too many uploads at once\n    if (this.isUploading) return;\n    // Kick off the queue\n    this.fire('uploadStart');\n    for (let num = 1; num <= this.simultaneousUploads; num++) {\n      this.uploadNextChunk();\n    }\n  }\n\n  /**\n   * Pause the upload\n   */\n  pause(): void {\n    // Resume all chunks currently being uploaded\n    for (const file of this.files) {\n      file.abort();\n    }\n    this.fire('pause');\n  };\n\n  /**\n   * Cancel uploading and reset all files to their initial states\n   */\n  cancel(): void {\n    this.fire('beforeCancel');\n    for (let i = this.files.length - 1; i >= 0; i--) {\n      this.files[i].cancel();\n    }\n    this.fire('cancel');\n  };\n\n  /**\n   * Return the progress of the current upload as a float between 0 and 1\n   */\n  progress(): number {\n    let totalDone = this.files.reduce((accumulator, file) => accumulator + file.size * file.progress(), 0);\n    let totalSize = this.getSize();\n    return totalSize > 0 ? totalDone / totalSize : 0;\n  };\n\n  /**\n   * Add a HTML5 File object to the list of files.\n   */\n  addFile(file: File, event: Event): void {\n    this.appendFilesFromFileList([file], event);\n  };\n\n  /**\n   * Add a list of HTML5 File objects to the list of files.\n   */\n  addFiles(files: File[], event: Event): void {\n    this.appendFilesFromFileList(files, event);\n  };\n\n  /**\n   * Add a validator function for the given file type. This can e.g. be used to read the file and validate\n   * checksums based on certain properties.\n   * @param fileType The file extension for the given validator\n   * @param validator A callback function that should be called when validating files with the given type\n   */\n  addFileValidator(fileType: string, validator: Function): void {\n    if (fileType in this.validators) {\n      console.warn(`Overwriting validator for file type: ${fileType}`);\n    }\n    this.validators[fileType] = validator;\n  }\n\n  /**\n   * Cancel the upload of a specific ResumableFile object and remove it from the file list.\n   */\n  removeFile(file: ResumableFile): void {\n    for (let i = this.files.length - 1; i >= 0; i--) {\n      if (this.files[i] === file) {\n        this.files.splice(i, 1);\n        break;\n      }\n    }\n  };\n\n  /**\n   * Retrieve a ResumableFile object from the file list by its unique identifier.\n   */\n  getFromUniqueIdentifier(uniqueIdentifier: string): ResumableFile {\n    return this.files.find((file) => file.uniqueIdentifier === uniqueIdentifier);\n  };\n\n  /**\n   * Get the combined size of all files for the upload\n   */\n  getSize(): number {\n    return this.files.reduce((accumulator, file) => accumulator + file.size, 0);\n  }\n\n  /**\n   * Call the event handler when a file is dropped on the drag-and-drop area\n   */\n  handleDropEvent(e: DragEvent): void {\n    this.onDrop(e);\n  }\n  /**\n   * Call the event handler when the provided input element changes (i.e. receives one or multiple files.\n   */\n  handleChangeEvent(e: InputEvent): void {\n    this.appendFilesFromFileList(Array.from((e.target as HTMLInputElement).files), e);\n    (e.target as HTMLInputElement).value = '';\n  }\n\n  /**\n   * Check whether the upload is completed, i.e. if all files were uploaded successfully.\n   */\n  checkUploadComplete(): void {\n    let uploadCompleted = this.files.every((file) => file.isComplete);\n    if (uploadCompleted) {\n      // All chunks have been uploaded, complete\n      this.fire('complete');\n    }\n  }\n\n  /**\n   * Event Handlers: This section should only include methods that are used to\n   * handle events coming from the files or chunks.\n   */\n\n  /**\n   * The event handler when a chunk was uploaded successfully\n   */\n  private handleChunkSuccess(): void {\n    this.uploadNextChunk();\n  }\n\n  /**\n   * The event handler when a chunk was uploaded successfully\n   */\n  private handleChunkError(): void {\n    this.uploadNextChunk();\n  }\n\n  /**\n   * The event handler when an error occurred during the upload of a chunk\n   */\n  private handleChunkCancel(): void {\n    this.uploadNextChunk();\n  }\n\n  /**\n   * The event handler when an error occurred during the upload of a file\n   */\n  private handleFileError(args: any[]): void {\n    this.fire('error', args[1], args[0]);\n  }\n\n  /**\n   * The event handler when all chunks from a file were uploaded successfully\n   */\n  private handleFileSuccess(args: any[]): void {\n    this.fire('fileSuccess', ...args);\n    this.checkUploadComplete();\n  }\n\n  /**\n   * The event handler when a file progress event was received\n   */\n  private handleFileProgress(): void {\n    this.fire('progress');\n  }\n\n  /**\n   * The event handler when the upload of a file was canceled\n   */\n  private handleFileCancel(args: any[]): void {\n    this.removeFile(args[0])\n  }\n\n  /**\n   * The event handler, when the retry of a file was initiated\n   */\n  private handleFileRetry(): void {\n    this.upload();\n  }\n}\n"],"names":["root","factory","exports","module","define","amd","this","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","stopEvent","e","stopPropagation","preventDefault","generateUniqueIdentifier","file","relativePath","webkitRelativePath","name","replace","size","flattenDeep","array","Array","isArray","reduce","a","b","concat","uniqBy","callback","errorCallback","seen","Set","filter","item","k","has","add","formatSize","toFixed","assignObject","target","varArgs","assign","TypeError","to","index","arguments","length","nextSource","nextKey","getTarget","requestType","sendTarget","testTarget","params","parameterNamespace","separator","indexOf","joinedParams","entries","map","encodeURIComponent","join","registeredEventHandlers","on","event","toLowerCase","push","fire","executeEventCallback","args","forEach","fileObj","offset","options","lastProgressCallback","Date","tested","retries","pendingRetry","isMarkedComplete","loaded","xhr","chunkSize","forceChunkSize","fileParameterName","chunkNumberParameterName","chunkSizeParameterName","currentChunkSizeParameterName","totalSizeParameterName","typeParameterName","identifierParameterName","fileNameParameterName","relativePathParameterName","totalChunksParameterName","throttleProgressCallbacks","query","headers","method","uploadMethod","testMethod","testChunks","maxChunkRetries","chunkRetryInterval","undefined","permanentErrors","withCredentials","xhrTimeout","chunkFormat","setChunkTypeFromFile","setInstanceProperties","fileObjSize","fileObjType","type","startByte","endByte","Math","min","setCustomHeaders","customHeaders","header","Function","setRequestHeader","customQuery","extraData","uniqueIdentifier","fileName","chunks","readyState","status","includes","abort","formattedQuery","test","XMLHttpRequest","testHandler","message","send","addEventListener","open","timeout","upload","now","getTime","doneHandler","retryInterval","setTimeout","bytes","slice","data","queryKey","FormData","append","fr","FileReader","onload","result","readAsDataURL","responseText","progress","relative","factor","markComplete","_prevProgress","isPaused","opts","_error","bootstrap","abortCount","chunk","cancel","retry","firedRetry","progressHandler","retryHandler","successHandler","isComplete","errorHandler","round","ceil","floor","maxOffset","max","ret","error","some","markChunksCompleted","chunkNumber","num","files","validators","clearInput","dragOverClass","fileTypes","fileTypeErrorCallback","alert","_generateUniqueIdentifier","maxFileSizeErrorCallback","maxFileSize","maxFilesErrorCallback","maxFiles","minFileSize","minFileSizeErrorCallback","prioritizeFirstAndLastChunk","fileValidationErrorCallback","simultaneousUploads","checkSupport","Resumable","support","File","Blob","FileList","Error","mapDirectoryItemToFile","path","isFile","Promise","resolve","reject","isDirectory","processDirectory","console","warn","mapDragItemToFile","entry","webkitGetAsEntry","getAsFile","directory","dirReader","createReader","allEntries","readEntries","all","onDrop","currentTarget","classList","remove","items","dataTransfer","from","promises","appendFilesFromFileList","onDragLeave","onDragOverEnter","dt","types","dropEffect","effectAllowed","validateFiles","uniqueFiles","validationPromises","addedFile","fileType","fileExtension","split","pop","substring","results","_v","fileList","removeFile","filesWithUniqueIdentifiers","validatedFiles","skippedFiles","f","handleChunkSuccess","handleChunkError","handleChunkCancel","handleFileProgress","handleFileError","handleFileSuccess","handleFileCancel","handleFileRetry","uploadNextChunk","assignBrowse","domNodes","HTMLElement","domNode","input","HTMLInputElement","document","createElement","setAttribute","style","display","opacity","focus","click","appendChild","removeAttribute","match","eventTarget","assignDrop","bind","unAssignDrop","removeEventListener","isUploading","pause","i","totalDone","accumulator","totalSize","getSize","addFile","addFiles","addFileValidator","validator","splice","getFromUniqueIdentifier","find","handleDropEvent","handleChangeEvent","checkUploadComplete","every"],"sourceRoot":""}