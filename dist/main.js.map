{"version":3,"file":"main.js","mappings":"CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,cAAe,GAAIH,GACA,iBAAZC,QACdA,QAAqB,YAAID,IAEzBD,EAAkB,YAAIC,GACvB,CATD,CASGK,MAAM,WACT,O,ubCVA,cACA,SACA,SAaA,MAAaC,UAAkB,UA2C7BC,YAAYC,EAAkC,CAAC,GAC7CC,QAtCM,KAAAC,MAA0C,CAAC,EAI3C,KAAAC,0BAAsC,GACtC,KAAAC,WAA6C,CAAC,EAItD,KAAAC,YAAsB,EACtB,KAAAC,cAAwB,WACxB,KAAAC,eAA2B,GAC3B,KAAAC,oBAAqC,UACrC,KAAAC,UAA2D,GAC3D,KAAAC,sBAAmCC,IACjCC,MAAM,GAAGD,EAAKE,UAAYF,EAAKG,qCAAqC,EAEtE,KAAAC,0BAAsC,KAEtC,KAAAC,yBAAsCL,IACpCC,MAAMD,EAAKE,UAAYF,EAAKG,KAAO,gDACjC,UAAQG,WAAWpB,KAAKqB,aAAe,IAAI,EAG/C,KAAAC,sBAAmCjB,IACjC,IAAIkB,EAAWvB,KAAKuB,SACpBR,MAAM,8BAAgCQ,EAAW,SAAwB,IAAbA,EAAiB,GAAK,KAAO,cAAc,EAEzG,KAAAC,YAAsB,EACtB,KAAAC,yBAAsCX,IACpCC,MAAMD,EAAKE,UAAYF,EAAKG,KAAO,kDACjC,UAAQG,WAAWpB,KAAKwB,aAAe,IAAI,EAE/C,KAAAE,6BAAuC,EACvC,KAAAC,4BAAyCb,IAAD,EACxC,KAAAc,oBAA8B,EAI5B5B,KAAK6B,sBAAsB1B,GAC3BH,KAAK8B,KAAO3B,EACZH,KAAK+B,cACP,CAUQA,eAMN,GALA/B,KAAKgC,aACMC,IAATC,WACSD,IAATE,WACaF,IAAbG,YACED,KAAKE,UAAUC,OACdtC,KAAKgC,QACR,MAAM,IAAIO,MAAM,2BAEpB,CAKUV,sBAAsB1B,GAI9B,GAHAqC,OAAOC,OAAOzC,KAAMG,GAGa,OAA7BH,KAAKW,qBACP,GAAmC,IAA/BX,KAAKU,eAAegC,OACtB,MAAM,IAAIH,MAAM,mFAERvC,KAAKU,eAAeiC,SAAS3C,KAAKW,qBAG5CiC,QAAQC,KAAK,yFAFb7C,KAAKU,eAAeoC,KAAK9C,KAAKW,qBAOhC,MAAMoC,EAA6B,GAcnC,GAbA/C,KAAKU,eAAesC,SAASC,IACvBjD,KAAKK,MAAM4C,KAIfjD,KAAKK,MAAM4C,GAAgB,GAC3BjD,KAAKM,0BAA0BwC,KAAKG,GACpCF,EAA2BD,KAAKG,GAAa,IAG/CjD,KAAKU,eAAiBqC,EAA2BT,QAG7CY,MAAMC,QAAQnD,KAAKY,WAAY,CAGjC,MAAMA,EAAYZ,KAAKY,UAAU0B,QAEjCtC,KAAKY,UAAY,CAAC,EAClBZ,KAAKU,eAAesC,SAASC,IAC3BjD,KAAKY,UAAUqC,GAAgBrC,EAAU0B,OAAO,G,KAE7C,CACL,MAAMc,EAAqBZ,OAAOa,KAAKrD,KAAKY,WAC5CZ,KAAKU,eAAesC,SAASC,IACtBG,EAAmBT,SAASM,IAC/BL,QAAQC,KAAK,kBAAoBI,EAAe,uFAGlDjD,KAAKY,UAAUqC,GAAgB,EAAE,G,CAIrCjD,KAAKsD,mBACP,CAEQA,oBAENd,OAAOa,KAAKrD,KAAKY,WAAWoC,SAASC,IACnCjD,KAAKY,UAAUqC,GAAgBjD,KAAKY,UAAUqC,GAAcM,KAAKC,GAASA,EAAKC,QAAQ,SAAU,IAAIC,eAAc,GAEvH,CAEQC,2BAA2BV,GACjC,IAAKjD,KAAKU,eAAeiC,SAASM,GAChC,MAAM,IAAIV,MAAM,0BAA4BU,EAEhD,CAQcW,uBAAuBC,EAAuBC,G,yCAC1D,GAAID,EAAKE,OAAQ,CAEf,MAAMjD,QAAa,IAAIkD,SACrB,CAACC,EAASC,IAAYL,EAA6B/C,KAAKmD,EAASC,KAGnE,OADApD,EAAKqD,aAAeL,EAAOhD,EAAKG,KACzB,CAACH,E,CACH,OAAI+C,EAAKO,kBAEDpE,KAAKqE,iBAAiBR,EAAkCC,EAAOD,EAAK5C,KAAO,KAC/E4C,aAAgB3B,KAClB,CAAC2B,IAGVjB,QAAQC,KAAK,yFACN,GACT,G,CAQcyB,kBAAkBT,EAAwBC,G,yCACtD,IAAIS,EAAQV,EAAKW,mBACjB,GAAID,EAAMH,YACR,aAAapE,KAAKqE,iBAAiBE,EAAmCT,EAAOS,EAAMtD,KAAO,KAG5F,IAAIH,EAAO+C,EAAKY,YAChB,OAAI3D,aAAgBoB,MACjBpB,EAAsBqD,aAAeL,EAAOhD,EAAKG,KAC3C,CAACH,KAGV8B,QAAQC,KAAK,yFACN,GACT,G,CAKQwB,iBAAiBK,EAAqCZ,GAC5D,OAAO,IAAIE,SAAQ,CAACC,EAASC,KAC3B,MAAMS,EAAYD,EAAUE,eAC5B,IAAIC,EAAa,GAEjB,MAAMC,EAAc,KAClBH,EAAUG,aAAmBC,GAA8C,EAAD,gCAExE,GAAIA,EAAQrC,OAEV,OADAmC,EAAaA,EAAWG,OAAOD,GACxBD,IAITD,EAAaA,EAAWtB,KAAKgB,GACpBvE,KAAK4D,uBAAuBW,EAAOT,KAG5CG,QAAcD,QAAQiB,IAAIJ,GAC5B,KAAGX,EAAO,EAGZY,GAAa,GAEjB,CAQQI,iCAAiCC,GACvC,MAAMC,EAAuBD,EAAEE,cAC/BD,EAAQE,UAAUC,OAAOvF,KAAKS,eAC9B,MAAMwC,EAAemC,EAAQI,aAAa,2BAI1C,OAFAxF,KAAK2D,2BAA2BV,GAEzBjD,KAAKyF,OAAON,EAAGlC,EACxB,CAKcwC,OAAON,EAAclC,EAAuBjD,KAAKW,qB,yCAC7D,UAAQ+E,UAAUP,GAElB,IAAIQ,EAAQ,GAWZ,GARIR,EAAES,cAAgBT,EAAES,aAAaD,MACnCA,EAAQ,IAAIR,EAAES,aAAaD,OAGpBR,EAAES,cAAgBT,EAAES,aAAavF,QACxCsF,EAAS,IAAIR,EAAES,aAAavF,SAGzBsF,EAAMjD,OACT,OAEF1C,KAAK6F,KAAK,sBAAuBF,EAAO1C,GACxC,IAAI6C,EAAWH,EAAMpC,KAAKM,GAAS7D,KAAKsE,kBAAkBT,EAAM,MAC5DxD,EAAQ,UAAQ0F,kBAAkB/B,QAAQiB,IAAIa,IAC9CzF,EAAMqC,QAER1C,KAAKgG,wBAAwB3F,EAAO8E,EAAGlC,EAE3C,G,CAKQgD,YAAYd,GACjBA,EAAEE,cAA8BC,UAAUC,OAAOvF,KAAKS,cACzD,CAKQyF,gBAAgBf,GACtBA,EAAEgB,iBACF,IAAIC,EAAKjB,EAAES,aACPQ,EAAGC,MAAM1D,SAAS,UACpBwC,EAAEmB,kBACFF,EAAGG,WAAa,OAChBH,EAAGI,cAAgB,OAClBrB,EAAEE,cAA8BC,UAAUmB,IAAIzG,KAAKS,iBAEpD2F,EAAGG,WAAa,OAChBH,EAAGI,cAAgB,OAEvB,CAQcE,cAAcrG,EAAuB4C,EAAuBjD,KAAKW,qB,yCAC7E,IAAKX,KAAKU,eAAeiC,SAASM,GAEhC,YADAjD,KAAK6F,KAAK,4BAAwB5D,EAAW,sBAAuBgB,GAKtE,IAAI0D,EAAc,UAAQC,OAAOvG,GAC9BS,GAASA,EAAK+F,mBACd/F,GAASd,KAAK6F,KAAK,uBAAwB/E,EAAM,YAAamC,KAGjE,MAAM6D,EAAiB9G,KAAKK,MAAM4C,GAClC,IAAI8D,EAAqBJ,EAAYpD,KAAWzC,GAAS,EAAD,gCAEtD,GAAIgG,EAAeE,MAAMC,GAAcA,EAAUJ,mBAAqB/F,EAAK+F,mBAEzE,OADA7G,KAAK6F,KAAK,uBAAwB/E,EAAM,YAAamC,IAC9C,EAGT,IAAIiE,EAAmBpG,EAAK0C,KAAKE,cAC7ByD,EAAgBrG,EAAKG,KAAKmG,MAAM,KAAKC,MAAM3D,cAE/C,OAAI1D,KAAKY,UAAUqC,GAAcP,OAAS,IAClB1C,KAAKY,UAAUqC,GAAc+D,MAAMxD,GAEhD2D,IAAkB3D,GAEvBA,EAAKb,SAAS,OACZa,EAAKb,SAAS,MACduE,EAASI,UAAU,EAAG9D,EAAK+D,QAAQ,QAAU/D,EAAK8D,UAAU,EAAG9D,EAAK+D,QAAQ,OAC5EL,IAAa1D,MAIjBxD,KAAK6F,KAAK,uBAAwB/E,EAAM,WAAYmC,GACpDjD,KAAKa,sBAAsBC,IACpB,QAKcmB,IAArBjC,KAAKwB,aAA6BV,EAAK0G,KAAOxH,KAAKwB,aACrDxB,KAAK6F,KAAK,uBAAwB/E,EAAM,cAAemC,GACvDjD,KAAKyB,yBAAyBX,IACvB,QAEgBmB,IAArBjC,KAAKqB,aAA6BP,EAAK0G,KAAOxH,KAAKqB,aACrDrB,KAAK6F,KAAK,uBAAwB/E,EAAM,cAAemC,GACvDjD,KAAKmB,yBAAyBL,IACvB,KAILqG,KAAiBnH,KAAKO,oBAAqBP,KAAKO,WAAW4G,GAAerG,EAAMmC,MAClFjD,KAAK6F,KAAK,uBAAwB/E,EAAM,aAAcmC,GACtDjD,KAAK2B,4BAA4Bb,GAC1B,GAIX,MAEA,MAAM2G,QAAgBzD,QAAQiB,IAAI8B,GAGlC,OAAO1G,EAAMqH,QAAO,CAACC,EAAIC,IAAUH,EAAQG,IAC7C,G,CASc5B,wBAAwB6B,EAAkBC,EAAc7E,EAAuBjD,KAAKW,qB,yCAChG,MAAMmG,EAAiB9G,KAAKK,MAAM4C,GAElC,IAAK6D,EAEH,OADA9G,KAAK6F,KAAK,4BAAwB5D,EAAW,sBAAuBgB,IAC7D,EAGT,MAAM8E,EAAoB/H,KAAKgI,0BAG/B,QAAsB/F,IAAlBjC,KAAKuB,UAA0BvB,KAAKuB,SAAWsG,EAASnF,OAASqF,EAAkBrF,OAAQ,CAE7F,GAAsB,IAAlB1C,KAAKuB,UAA+C,IAA7BwG,EAAkBrF,QAAoC,IAApBmF,EAASnF,OAKpE,OAFA1C,KAAK6F,KAAK,4BAAwB5D,EAAW,WAAYgB,GACzDjD,KAAKsB,sBAAsBuG,IACpB,EAJP7H,KAAKiI,WAAWnB,EAAe,G,CAUnC,MAAMoB,QAAmClE,QAAQiB,IAAI4C,EAAStE,KAAWzC,GAA8C,EAAD,gCAEpH,OADAA,EAAK+F,uBAAyB7G,KAAKmI,yBAAyBrH,EAAMgH,EAAO7E,GAClEnC,CACT,OAGMsH,QAAuBpI,KAAK0G,cAAcwB,EAA4BjF,GAE5E,IAAIoF,EAAeH,EAA2BR,QAAQ5G,IAAUsH,EAAezF,SAAS7B,KAExF,IAAK,MAAMA,KAAQsH,EAAgB,CACjC,IAAIE,EAAI,IAAI,UAAcxH,EAAMA,EAAK+F,iBAAkB5D,EAAcjD,KAAK8B,MAC1EwG,EAAEC,GAAG,gBAAgB,IAAMvI,KAAKwI,uBAChCF,EAAEC,GAAG,cAAc,IAAMvI,KAAKyI,qBAC9BH,EAAEC,GAAG,eAAe,IAAMvI,KAAK0I,sBAC/BJ,EAAEC,GAAG,gBAAgB,IAAII,IAAS3I,KAAK4I,mBAAmBD,EAAM1F,KAChEqF,EAAEC,GAAG,aAAa,IAAII,IAAS3I,KAAK6I,gBAAgBF,EAAM1F,KAC1DqF,EAAEC,GAAG,eAAe,IAAII,IAAS3I,KAAK8I,kBAAkBH,EAAM1F,KAC9DqF,EAAEC,GAAG,cAAc,IAAII,IAAS3I,KAAK+I,iBAAiBJ,KACtDL,EAAEC,GAAG,aAAa,IAAMvI,KAAKgJ,oBAC7BhJ,KAAKK,MAAM4C,GAAcH,KAAKwF,GAC9BtI,KAAK6F,KAAK,YAAayC,EAAGR,EAAO7E,E,EAI9BmF,EAAe1F,QAAW2F,EAAa3F,SAI5C1C,KAAK6F,KAAK,aAAcuC,EAAgBC,EAAcpF,EACxD,G,CASQkF,yBAAyBrH,EAAYgH,EAAc7E,EAAuBjD,KAAKW,qBACrF,MAAiD,mBAAnCX,KAAKkB,0BACjBlB,KAAKkB,0BAA0BJ,EAAMgH,EAAO7E,GAAgB,UAAQkF,yBAAyBrH,EACjG,CAKQmI,kBACN,MAAMlB,EAAoB/H,KAAKgI,0BAK/B,GAAIhI,KAAK0B,4BACP,IAAK,MAAMZ,KAAQiH,EAAmB,CACpC,GAAIjH,EAAKoI,OAAOxG,QAAoC,iBAA1B5B,EAAKoI,OAAO,GAAGC,OAEvC,YADArI,EAAKoI,OAAO,GAAGE,OAGjB,GAAItI,EAAKoI,OAAOxG,OAAS,GAAoD,iBAA/C5B,EAAKoI,OAAOpI,EAAKoI,OAAOxG,OAAS,GAAGyG,OAEhE,YADArI,EAAKoI,OAAOpI,EAAKoI,OAAOxG,OAAS,GAAG0G,M,CAO1C,IAAK,MAAMtI,KAAQiH,EACjB,GAAIjH,EAAKuI,SAAU,MAEvB,CASQrB,0BACN,IAAIsB,EAAW,GAMf,OAJAtJ,KAAKU,eAAesC,SAASC,IAC3BqG,EAAWA,EAAStE,OAAOhF,KAAKK,MAAM4C,GAAc,IAG/CqG,CACT,CAcAC,aAAaC,EAAuCpF,GAAuB,EAAOnB,EAAuBjD,KAAKW,qBAC5GX,KAAK2D,2BAA2BV,GAE5BuG,aAAoBC,cAAaD,EAAW,CAACA,IACjD,IAAK,MAAMpE,KAAWoE,EAAU,CAC9B,IAAIE,EACAtE,aAAmBuE,kBAAqC,SAAjBvE,EAAQ5B,KACjDkG,EAAQtE,GAERsE,EAAQE,SAASC,cAAc,SAC/BH,EAAMI,aAAa,OAAQ,QAC3BJ,EAAMK,MAAMC,QAAU,OACtB5E,EAAQ6E,iBAAiB,SAAS,KAChCP,EAAMK,MAAMG,QAAU,EACtBR,EAAMK,MAAMC,QAAU,QACtBN,EAAMS,QACNT,EAAMU,QACNV,EAAMK,MAAMC,QAAU,MAAM,IAC3B,GACH5E,EAAQiF,YAAYX,IAEA,IAAlB1J,KAAKuB,SACPmI,EAAMI,aAAa,WAAY,YAE/BJ,EAAMY,gBAAgB,YAEpBlG,EACFsF,EAAMI,aAAa,kBAAmB,mBAEtCJ,EAAMY,gBAAgB,mBAKxBtK,KAAKuK,aAAavK,KAAKY,UAAUqC,GAAeyG,EAAOzG,GAEvDyG,EAAMO,iBACJ,UACCnC,IACC9H,KAAKwK,kBAAkB1C,EAAO7E,EAAa,IAE7C,E,CAGN,CAQAwH,WAAWjB,EAAuCvG,EAAuBjD,KAAKW,qBAC5EX,KAAK2D,2BAA2BV,GAE5BuG,aAAoBC,cAAaD,EAAW,CAACA,IAEjD,IAAK,MAAMpE,KAAWoE,EAChBvG,GAKFmC,EAAQ0E,aAAa,0BAA2B7G,GAGlDmC,EAAQ6E,iBAAiB,WAAYjK,KAAKkG,gBAAgBwE,KAAK1K,OAAO,GACtEoF,EAAQ6E,iBAAiB,YAAajK,KAAKkG,gBAAgBwE,KAAK1K,OAAO,GACvEoF,EAAQ6E,iBAAiB,YAAajK,KAAKiG,YAAYyE,KAAK1K,OAAO,GACnEoF,EAAQ6E,iBAAiB,OAAQjK,KAAKkF,iCAAiCwF,KAAK1K,OAAO,EAEvF,CAKA2K,aAAanB,GACPA,aAAoBC,cAAaD,EAAW,CAACA,IAEjD,IAAK,MAAMpE,KAAWoE,EACpBpE,EAAQwF,oBAAoB,WAAY5K,KAAKkG,gBAAgBwE,KAAK1K,OAClEoF,EAAQwF,oBAAoB,YAAa5K,KAAKkG,gBAAgBwE,KAAK1K,OACnEoF,EAAQwF,oBAAoB,YAAa5K,KAAKiG,YAAYyE,KAAK1K,OAC/DoF,EAAQwF,oBAAoB,OAAQ5K,KAAKkF,iCAAiCwF,KAAK1K,MAEnF,CAWAuK,aAAa3J,EAAqBwE,EAA4B,KAAMnC,EAAuBjD,KAAKW,qBAG9F,GAFAX,KAAK2D,2BAA2BV,GAE5BmC,GAA4B,SAAjBA,EAAQ5B,KACrB,MAAM,IAAIjB,MAAM,iCAIlBvC,KAAKY,UAAUqC,GAAgBrC,EAC/BZ,KAAKsD,oBAED8B,IACExE,EAAU8B,QAAU,EAEtB0C,EAAQ0E,aAAa,SAAU9J,KAAKY,UAAUqC,GAAcM,KAAKC,IAC3DA,EAAKqH,MAAM,iBACbrH,EAAO,IAAMA,GAERA,KACNsH,KAAK,MAGR1F,EAAQkF,gBAAgB,UAG9B,CAKIS,kBACF,OAAO/K,KAAKgI,0BAA0BhB,MAAMlG,GAASA,EAAKiK,aAC5D,CAKA1B,SAEE,IAAIrJ,KAAK+K,YAAT,CAEA/K,KAAK6F,KAAK,eACV,IAAK,IAAImF,EAAM,EAAGA,GAAOhL,KAAK4B,oBAAqBoJ,IACjDhL,KAAKiJ,iBAJqB,CAM9B,CAKAgC,QAEE,IAAK,MAAMnK,KAAQd,KAAKgI,0BACtBlH,EAAKoK,QAEPlL,KAAK6F,KAAK,QACZ,CAKAsF,SACEnL,KAAK6F,KAAK,gBACO7F,KAAKgI,0BACbhF,SAASlC,IAChBA,EAAKqK,QAAQ,IAGfnL,KAAK6F,KAAK,SACZ,CAKAuF,WACE,IAAIC,EAAYrL,KAAKgI,0BAA0BsD,QAAO,CAACC,EAAazK,IAASyK,EAAczK,EAAK0G,KAAO1G,EAAKsK,YAAY,GACpHI,EAAYxL,KAAKyL,UACrB,OAAOD,EAAY,EAAIH,EAAYG,EAAY,CACjD,CAKAE,QAAQ5K,EAAYgH,EAAc7E,EAAuBjD,KAAKW,qBAC5DX,KAAK2D,2BAA2BV,GAEhCjD,KAAKgG,wBAAwB,CAAClF,GAAOgH,EAAO7E,EAC9C,CAKA0I,SAAStL,EAAeyH,EAAc7E,EAAuBjD,KAAKW,qBAChEX,KAAK2D,2BAA2BV,GAEhCjD,KAAKgG,wBAAwB3F,EAAOyH,EAAO7E,EAC7C,CAQA2I,iBAAiB1E,EAAkB2E,GAC7B3E,KAAYlH,KAAKO,YACnBqC,QAAQC,KAAK,wCAAwCqE,KAEvDlH,KAAKO,WAAW2G,GAAY2E,CAC9B,CAKA5D,WAAWnH,GACT,MAAMmC,EAAenC,EAAKmC,aACpB6I,EAAY9L,KAAKK,MAAM4C,GAAc8I,WACxCC,GAAkBA,EAAcnF,mBAAqB/F,EAAK+F,mBAGzDiF,GAAa,GACf9L,KAAKK,MAAM4C,GAAcgJ,OAAOH,EAAW,EAE/C,CAKAI,wBAAwBrF,GACtB,OAAO7G,KAAKgI,0BAA0BmE,MAAMrL,GAASA,EAAK+F,mBAAqBA,GACjF,CAKA4E,UACE,OAAOzL,KAAKgI,0BAA0BsD,QAAO,CAACC,EAAazK,IAASyK,EAAczK,EAAK0G,MAAM,EAC/F,CAKA4E,gBAAgBjH,EAAclC,EAAuBjD,KAAKW,qBACxDX,KAAK2D,2BAA2BV,GAEhCjD,KAAKyF,OAAON,EAAGlC,EACjB,CAKAuH,kBAAkBrF,EAAelC,EAAuBjD,KAAKW,qBAC3DX,KAAK2D,2BAA2BV,GAEhC,MAAMoJ,EAAclH,EAAEmH,OACtBtM,KAAK6F,KAAK,sBAAuBwG,EAAYhM,MAAO4C,GACpDjD,KAAKgG,wBAAwB,IAAIqG,EAAYhM,OAAe8E,EAAGlC,GAC3DjD,KAAKQ,aACP6L,EAAYE,MAAQ,GAExB,CAMAC,sBAEE,GAA8C,IAA1CxM,KAAKgI,0BAA0BtF,OACjC,OAGF,MAAM+J,EAAiC,GACvCzM,KAAKM,0BAA0B0C,SAASC,IAEC,GAAnCjD,KAAKK,MAAM4C,GAAcP,SAIzB1C,KAAKK,MAAM4C,GAAcyJ,OAAO5L,GAASA,EAAK6L,aAChD3M,KAAK6F,KAAK,mBAAoB5C,GAE9BwJ,EAA+B3J,KAAKG,G,IAIxCjD,KAAKM,0BAA4BmM,EAEa,IAA1CzM,KAAKM,0BAA0BoC,QAEjC1C,KAAK6F,KAAK,WAEd,CAUQ2C,qBACNxI,KAAKiJ,iBACP,CAKQR,mBACNzI,KAAKiJ,iBACP,CAKQP,oBACN1I,KAAKiJ,iBACP,CAKQJ,gBAAgBF,EAAa1F,GACnCjD,KAAK6F,KAAK,QAAS8C,EAAK,GAAIA,EAAK,GAAI1F,EACvC,CAKQ6F,kBAAkBH,EAAa1F,GACrCjD,KAAK6F,KAAK,iBAAkB8C,EAAM1F,GAClCjD,KAAKwM,qBACP,CAKQ5D,mBAAmBD,EAAa1F,GACtCjD,KAAK6F,KAAK,kBAAmB8C,EAAM1F,GACnCjD,KAAK6F,KAAK,WACZ,CAKQkD,iBAAiBJ,GACvB3I,KAAKiI,WAAWU,EAAK,GACvB,CAKQK,kBACNhJ,KAAKqJ,QACP,EAz0BF,a,uECfA,cACA,SAOA,MAAqBuD,UAAuB,UA+C1C1M,YAAY2M,EAAwBC,EAAgB3M,GAClDC,QA3CM,KAAA2M,qBAA6B,IAAIC,KACjC,KAAAC,QAAkB,EAClB,KAAAC,QAAkB,EAClB,KAAAC,cAAwB,EACxB,KAAAC,kBAA4B,EAC5B,KAAAC,OAAiB,EAGjB,KAAAC,IAAsB,KAGtB,KAAAC,UAAoB,QACpB,KAAAC,kBAA4B,OACpC,KAAAC,yBAAmC,uBACnC,KAAAC,uBAAiC,qBACjC,KAAAC,8BAAwC,4BACxC,KAAAC,uBAAiC,qBACjC,KAAAC,kBAA4B,gBAC5B,KAAAC,wBAAkC,sBAClC,KAAAC,0BAAoC,wBACpC,KAAAC,sBAAgC,oBAChC,KAAAC,0BAAoC,wBACpC,KAAAC,yBAAmC,uBACnC,KAAAC,0BAAoC,GACpC,KAAAC,MAAgB,CAAC,EACjB,KAAAC,QAAkB,CAAC,EACnB,KAAAC,OAAiB,YACjB,KAAAC,aAAuB,OACvB,KAAAC,WAAqB,MACrB,KAAAC,mBAA6B,GAC7B,KAAAC,YAAsB,EACtB,KAAAC,gBAA0B,IAC1B,KAAAC,wBAA8B3M,EAC9B,KAAA4M,gBAA4B,CAAC,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,KAChE,KAAAC,iBAA2B,EAC3B,KAAAC,WAAqB,EACrB,KAAAC,YAAsB,OACtB,KAAAC,sBAAgC,EAChC,KAAA3C,OAAiB,IACjB,KAAA4C,WAAqB,GAKnBlP,KAAK6B,sBAAsB1B,GAC3BH,KAAK6M,QAAUA,EACf7M,KAAKmP,YAActC,EAAQrF,KAC3BxH,KAAKoP,YAAcvC,EAAQ/L,KAAK0C,KAChCxD,KAAK8M,OAASA,EAGd9M,KAAKqP,UAAYrP,KAAK8M,OAAS9M,KAAKuN,UACpCvN,KAAKsP,QAAUC,KAAKC,IAAIxP,KAAKmP,aAAcnP,KAAK8M,OAAS,GAAK9M,KAAKuN,WACnEvN,KAAKsN,IAAM,IACb,CAKUzL,sBAAsB1B,GAC9BqC,OAAOC,OAAOzC,KAAMG,EACtB,CAKAsP,mBACE,IAAKzP,KAAKsN,IACR,OAEF,IAAIoC,EAAgB1P,KAAKqO,QACrBqB,aAAyBC,WAC3BD,EAAgBA,EAAc1P,KAAK6M,QAAS7M,OAE9C,IAAK,MAAM4P,KAAUF,EACdA,EAAcG,eAAeD,IAClC5P,KAAKsN,IAAIwC,iBAAiBF,EAAQF,EAAcE,GAEpD,CAKIG,qBACF,IAAIC,EAAchQ,KAAKoO,MACG,mBAAf4B,IAA2BA,EAAcA,EAAYhQ,KAAK6M,QAAS7M,OAG9E,MAAMiQ,EAAY,CAEhB,CAACjQ,KAAKyN,0BAA2BzN,KAAK8M,OAAS,EAC/C,CAAC9M,KAAK0N,wBAAyB1N,KAAKuN,UACpC,CAACvN,KAAK2N,+BAAgC3N,KAAKsP,QAAUtP,KAAKqP,UAC1D,CAACrP,KAAK4N,wBAAyB5N,KAAKmP,YACpC,CAACnP,KAAK6N,mBAAoB7N,KAAKoP,YAC/B,CAACpP,KAAK8N,yBAA0B9N,KAAK6M,QAAQhG,iBAC7C,CAAC7G,KAAK+N,2BAA4B/N,KAAK6M,QAAQ5J,aAC/C,CAACjD,KAAKgO,uBAAwBhO,KAAK6M,QAAQ7L,SAC3C,CAAChB,KAAKiO,2BAA4BjO,KAAK6M,QAAQ1I,aAC/C,CAACnE,KAAKkO,0BAA2BlO,KAAK6M,QAAQ3D,OAAOxG,QAEvD,OAAO,OAAP,wBAAWuN,GAAcD,EAC3B,CAKI7G,aACF,OAAInJ,KAAKmN,aAGA,iBACEnN,KAAKoN,iBACP,eACGpN,KAAKsN,IAENtN,KAAKsN,IAAI4C,WAAa,EAExB,iBACsB,MAApBlQ,KAAKsN,IAAInE,QAAsC,MAApBnJ,KAAKsN,IAAInE,OAEtC,eACEnJ,KAAK6O,gBAAgBlM,SAAS3C,KAAKsN,IAAInE,SAAWnJ,KAAKkN,SAAWlN,KAAK2O,gBAEzE,cAIP3O,KAAKkL,QACE,gBAdA,cAgBX,CAMAiF,UAAUC,GACR,OAAO,UAAQD,UAAUC,EAAapQ,KAAKsM,OAAQtM,KAAKkP,WAAYlP,KAAK+P,eAAgB/P,KAAKyO,mBAChG,CAKA4B,OAEErQ,KAAKsN,IAAM,IAAIgD,eAEf,IAAIC,EAAc,KAChBvQ,KAAKiN,QAAS,EAEC,iBADFjN,KAAKmJ,OAEhBnJ,KAAK6F,KAAK,eAAgB7F,KAAKwQ,WAE/BxQ,KAAKoJ,M,EAGTpJ,KAAKsN,IAAIrD,iBAAiB,OAAQsG,GAAa,GAC/CvQ,KAAKsN,IAAIrD,iBAAiB,QAASsG,GAAa,GAChDvQ,KAAKsN,IAAIrD,iBAAiB,UAAWsG,GAAa,GAGlDvQ,KAAKsN,IAAImD,KAAKzQ,KAAKwO,WAAYxO,KAAKmQ,UAAU,SAC9CnQ,KAAKsN,IAAIoD,QAAU1Q,KAAK+O,WACxB/O,KAAKsN,IAAIwB,gBAAkB9O,KAAK8O,gBAEhC9O,KAAKyP,mBAELzP,KAAKsN,IAAIlE,KAAK,KAChB,CAKA8B,QACMlL,KAAKsN,KAAKtN,KAAKsN,IAAIpC,QACvBlL,KAAKsN,IAAM,IACb,CAKAlE,OACE,GAAIpJ,KAAK0O,aAAe1O,KAAKiN,OAE3B,YADAjN,KAAKqQ,OAKPrQ,KAAKsN,IAAM,IAAIgD,eAGftQ,KAAKsN,IAAIjE,OAAOY,iBAAiB,YAAa9E,IACxC6H,KAAK2D,MAAQ3Q,KAAK+M,qBAAqB6D,UAA6C,IAAjC5Q,KAAKmO,4BAC1DnO,KAAK6F,KAAK,iBACV7F,KAAK+M,qBAAuB,IAAIC,MAElChN,KAAKqN,OAASlI,EAAEkI,QAAU,CAAC,IAC1B,GACHrN,KAAKqN,OAAS,EACdrN,KAAKmN,cAAe,EACpBnN,KAAK6F,KAAK,iBAKV,IAAIgL,EAAc,KAChB,IAAI1H,EAASnJ,KAAKmJ,OAClB,OAAQA,GACN,IAAK,eACL,IAAK,aACHnJ,KAAK6F,KAAKsD,EAAQnJ,KAAKwQ,WACvB,MACF,QACExQ,KAAK6F,KAAK,aAAc7F,KAAKwQ,WAC7BxQ,KAAKkL,QACLlL,KAAKkN,UACL,IAAI4D,EAAgB9Q,KAAK4O,wBACH3M,IAAlB6O,GACF9Q,KAAKmN,cAAe,EACpB4D,WAAW/Q,KAAKoJ,KAAM0H,IAEtB9Q,KAAKoJ,O,EAKbpJ,KAAKsN,IAAIrD,iBAAiB,OAAQ4G,GAAa,GAC/C7Q,KAAKsN,IAAIrD,iBAAiB,QAAS4G,GAAa,GAChD7Q,KAAKsN,IAAIrD,iBAAiB,UAAW4G,GAAa,GAGlD,IAAIG,EAAQhR,KAAK6M,QAAQ/L,KAAKwB,MAAMtC,KAAKqP,UAAWrP,KAAKsP,QACvDtP,KAAKiP,qBAAuBjP,KAAK6M,QAAQ/L,KAAK0C,KAAO,IACnDyN,EAAO,KACPxC,EAAqBzO,KAAKyO,mBAE9B,GAAoB,UAAhBzO,KAAKsO,OACP2C,EAAOD,MACF,CACLC,EAAO,IAAIC,SACX,IAAK,MAAMC,KAAYnR,KAAK+P,eAC1BkB,EAAKG,OAAO3C,EAAqB0C,EAAUnR,KAAK+P,eAAeoB,IAEjE,OAAQnR,KAAKgP,aACX,IAAK,OACHiC,EAAKG,OAAO3C,EAAqBzO,KAAKwN,kBAAmBwD,EAAOhR,KAAK6M,QAAQ7L,UAC7E,MACF,IAAK,SACH,IAAIqQ,EAAK,IAAIC,WACbD,EAAGE,OAAS,KACVN,EAAKG,OAAO3C,EAAqBzO,KAAKwN,kBAAmB6D,EAAGG,QAC5DxR,KAAKsN,IAAIlE,KAAK6H,EAAK,EAErBI,EAAGI,cAAcT,G,CAKvB,IAAI1E,EAAStM,KAAKmQ,UAAU,UAE5BnQ,KAAKsN,IAAImD,KAAKzQ,KAAKuO,aAAcjC,GACb,UAAhBtM,KAAKsO,QACPtO,KAAKsN,IAAIwC,iBAAiB,eAAgB,4BAE5C9P,KAAKsN,IAAIoD,QAAU1Q,KAAK+O,WACxB/O,KAAKsN,IAAIwB,gBAAkB9O,KAAK8O,gBAEhC9O,KAAKyP,mBAEoB,SAArBzP,KAAKgP,aACPhP,KAAKsN,IAAIlE,KAAK6H,EAElB,CAKAT,UACE,OAAOxQ,KAAKsN,IAAMtN,KAAKsN,IAAIoE,aAAe,EAC5C,CAMAtG,SAASuG,GAAoB,GAC3B,IAAIC,EAASD,GAAY3R,KAAKsP,QAAUtP,KAAKqP,WAAarP,KAAKmP,YAAc,EAC7E,GAAInP,KAAKmN,aAAc,OAAO,EAE9B,OADMnN,KAAKsN,KAAQtN,KAAKsN,IAAInE,QAAYnJ,KAAKoN,mBAAkBwE,GAAU,KACjE5R,KAAKmJ,QACX,IAAK,eACL,IAAK,aACH,OAAOyI,EACT,IAAK,eACH,OAAO,EACT,QACE,OAAO5R,KAAKqN,QAAUrN,KAAKsP,QAAUtP,KAAKqP,WAAauC,EAE7D,CAKAC,eACE7R,KAAKoN,kBAAmB,CAC1B,EAvTF,W,qECJA,gBAMElN,cACEF,KAAK8R,wBAA0B,CAAC,CAClC,CAKAvJ,GAAGT,EAAeiK,GAChBjK,EAAQA,EAAMpE,cACT1D,KAAK8R,wBAAwBjC,eAAe/H,KAC/C9H,KAAK8R,wBAAwBhK,GAAS,IAExC9H,KAAK8R,wBAAwBhK,GAAOhF,KAAKiP,EAC3C,CAKAlM,KAAKiC,KAAkBa,GACrBb,EAAQA,EAAMpE,cAEd1D,KAAKgS,qBAAqBlK,KAAUa,GACpC3I,KAAKgS,qBAAqB,IAAKlK,KAAUa,EAC3C,CAMQqJ,qBAAqBlK,KAAkBa,GACxC3I,KAAK8R,wBAAwBjC,eAAe/H,IACjD9H,KAAK8R,wBAAwBhK,GAAO9E,SAAS+O,GAAaA,KAAYpJ,IACxE,E,uEC1CF,eAEA,SAMA,MAAqBsJ,UAAsB,UAezC/R,YAAYY,EAAY+F,EAA0B5D,EAAsB9C,GACtEC,QAdM,KAAA8R,cAAwB,EACxB,KAAAC,UAAoB,EAS5B,KAAAjJ,OAA2B,GACnB,KAAAqE,UAAoB,QAI1BvN,KAAK8B,KAAO3B,EACZH,KAAK6B,sBAAsB1B,GAC3BH,KAAKc,KAAOA,EACZd,KAAKgB,SAAWF,EAAKG,KACrBjB,KAAKwH,KAAO1G,EAAK0G,KACjBxH,KAAKmE,aAAerD,EAAKsR,oBAAsBpS,KAAKgB,SACpDhB,KAAK6G,iBAAmBA,EACxB7G,KAAKiD,aAAeA,EACpBjD,KAAKqS,YAA8BpQ,IAArB4E,EAGd7G,KAAK6F,KAAK,gBAAiB7F,MAC3BA,KAAKsS,WACP,CAKUzQ,sBAAsB1B,GAC9BqC,OAAOC,OAAOzC,KAAMG,EACtB,CAKA+K,QACE,IAAIqH,EAAa,EACjB,IAAK,MAAMC,KAASxS,KAAKkJ,OACF,mBAAjBsJ,EAAMrJ,SACRqJ,EAAMtH,QACNqH,KAGAA,EAAa,GAAGvS,KAAK6F,KAAK,eAAgB7F,KAAM,KACtD,CAKAmL,SACE,IAAK,MAAMqH,KAASxS,KAAKkJ,OACF,mBAAjBsJ,EAAMrJ,SACRqJ,EAAMtH,QACNlL,KAAK6F,KAAK,cAAe2M,IAI7BxS,KAAKkJ,OAAS,GACdlJ,KAAK6F,KAAK,aAAc7F,MACxBA,KAAK6F,KAAK,eAAgB7F,KAAM,KAClC,CAKAyS,QACEzS,KAAKsS,YACL,IAAII,GAAa,EACjB1S,KAAKuI,GAAG,oBAAoB,KACrBmK,GAAY1S,KAAK6F,KAAK,aAC3B6M,GAAa,CAAI,GAErB,CAKAJ,YACE,MAAMK,EAAmBnC,GAAYxQ,KAAK6F,KAAK,eAAgB7F,KAAMwQ,GAC/DoC,EAAe,IAAO5S,KAAK6F,KAAK,YAAa7F,MAC7C6S,EAAkBrC,IAClBxQ,KAAKqS,SACTrS,KAAK6F,KAAK,gBACV7F,KAAK6F,KAAK,eAAgB7F,KAAMwQ,GAC5BxQ,KAAK2M,YACP3M,KAAK6F,KAAK,cAAe7F,KAAMwQ,G,EAG7BsC,EAAgBtC,IACpBxQ,KAAK6F,KAAK,aAAc2K,GACxBxQ,KAAKkL,QACLlL,KAAKqS,QAAS,EACdrS,KAAKkJ,OAAS,GACdlJ,KAAK6F,KAAK,YAAa7F,KAAMwQ,EAAQ,EAGvCxQ,KAAKkL,QACLlL,KAAKqS,QAAS,EAEdrS,KAAKkJ,OAAS,GACdlJ,KAAKkS,cAAgB,EACrB,MAAMa,EAAYxD,KAAKyD,IAAIzD,KAAK0D,KAAKjT,KAAKc,KAAK0G,KAAOxH,KAAKuN,WAAY,GACvE,IAAK,IAAIT,EAAS,EAAGA,EAASiG,EAAWjG,IAAU,CACjD,MAAM0F,EAAQ,IAAI,UAAexS,KAAM8M,EAAQ9M,KAAK8B,MACpD0Q,EAAMjK,GAAG,gBAAiBoK,GAC1BH,EAAMjK,GAAG,aAAcuK,GACvBN,EAAMjK,GAAG,eAAgBsK,GACzBL,EAAMjK,GAAG,aAAcqK,GACvB5S,KAAKkJ,OAAOpG,KAAK0P,GACjBxS,KAAK6F,KAAK,mBAAoB7F,KAAM8M,EAASiG,E,CAE/C/S,KAAK6F,KAAK,mBAAoB7F,KAChC,CAKAoL,WACE,GAAIpL,KAAKqS,OAAQ,OAAO,EAExB,IAAIa,EAAM,EACNC,GAAQ,EACZ,IAAK,MAAMX,KAASxS,KAAKkJ,OACF,eAAjBsJ,EAAMrJ,SAAuCgK,GAAQ,GACzDD,GAAOV,EAAMpH,UAAS,GAKxB,OAHA8H,EAAMC,GAAaD,EAAM,OAAX,EAAyBA,EACvCA,EAAM3D,KAAKyD,IAAIhT,KAAKkS,cAAegB,GACnClT,KAAKkS,cAAgBgB,EACdA,CACT,CAKInI,kBACF,OAAO/K,KAAKkJ,OAAOlC,MAAMwL,GAA2B,mBAAjBA,EAAMrJ,QAC3C,CAMIwD,iBACF,OAAQ3M,KAAKkJ,OAAOlC,MAAMwL,GACP,iBAAjBA,EAAMrJ,QAA4D,mBAAjBqJ,EAAMrJ,QAC3D,CAKAE,SACE,GAAIrJ,KAAKmS,SACP,OAAO,EAGT,IAAK,MAAMK,KAASxS,KAAKkJ,OACvB,GAAqB,iBAAjBsJ,EAAMrJ,OAER,OADAqJ,EAAMpJ,QACC,EAGX,OAAO,CACT,CAMAgK,oBAAoBC,GAClB,GAAKrT,KAAKkJ,UAAUlJ,KAAKkJ,OAAOxG,QAAU2Q,GAG1C,IAAK,IAAIrI,EAAM,EAAGA,EAAMqI,EAAarI,IACnChL,KAAKkJ,OAAO8B,GAAK6G,cAErB,EAvLF,W,oECLA,gBAIEyB,iBAAiBnO,GACfA,EAAEmB,kBACFnB,EAAEgB,gBACJ,CAOAmN,gCAAgCxS,GAC9B,IAAIqD,EAAerD,EAAKsR,oBAAsBtR,EAAKqD,cAAgBrD,EAAKG,KAIxE,OAFAkD,EAAeA,EAAaV,QAAQ,IAAK,KAEjC3C,EAAK0G,KAAO,IAAMrD,EAAaV,QAAQ,oBAAqB,GACtE,CAMA6P,mBAAmBC,GACjB,OAAOrQ,MAAMC,QAAQoQ,GACjBA,EAAMjI,QAAO,CAACkI,EAAGC,IAAMD,EAAExO,OAAOhF,KAAK+F,YAAY0N,KAAK,IACtD,CAACF,EACP,CAMAD,cAAcC,EAAcxB,EAAoB2B,GAC9C,IAAIC,EAAO,IAAIC,IACf,OAAOL,EAAM7L,QAAQ7D,IACnB,IAAIgQ,EAAI9B,EAASlO,GACjB,OAAI8P,EAAKG,IAAID,IACXH,EAAc7P,IACP,IAEP8P,EAAKlN,IAAIoN,IACF,E,GAGb,CAKAP,kBAAkB9L,GAChB,OAAIA,EAAO,KACFA,EAAO,SAEZA,EAAO,SACDA,EAAO,MAAQuM,QAAQ,GAAK,MAElCvM,EAAO,YACDA,EAAO,KAAS,MAAQuM,QAAQ,GAAK,OAEvCvM,EAAO,KAAS,KAAS,MAAQuM,QAAQ,GAAK,KACxD,CAKAT,iBACElD,EACA4D,EACA9E,EACA+E,EACAxF,EAA6B,IAE7B,IAAInC,EAAS0H,EAEO,SAAhB5D,GAA0BlB,IAC5B5C,EAAwB,MAAf4C,EAAqB8E,EAAa9E,GAG7C,IAAIgF,EAAY5H,EAAO/E,QAAQ,KAAO,EAAI,IAAM,IAC5C4M,EAAe3R,OAAOuC,QAAQkP,GAAQ1Q,KAAI,EAAE6Q,EAAK7H,KAAW,CAC9D8H,mBAAmB5F,EAAqB2F,GACxCC,mBAAmB9H,IACnBzB,KAAK,OAAMA,KAAK,KAIlB,OAFIqJ,IAAc7H,EAASA,EAAS4H,EAAYC,GAEzC7H,CACT,E,GC7FEgI,EAA2B,CAAC,E,OAGhC,SAASC,EAAoBC,GAE5B,IAAIC,EAAeH,EAAyBE,GAC5C,QAAqBvS,IAAjBwS,EACH,OAAOA,EAAa7U,QAGrB,IAAIC,EAASyU,EAAyBE,GAAY,CAGjD5U,QAAS,CAAC,GAOX,OAHA8U,EAAoBF,GAAUG,KAAK9U,EAAOD,QAASC,EAAQA,EAAOD,QAAS2U,GAGpE1U,EAAOD,OACf,CCnB0B2U,CAAoB,I","sources":["webpack://resumablejs/webpack/universalModuleDefinition","webpack://resumablejs/./src/resumable.ts","webpack://resumablejs/./src/resumableChunk.ts","webpack://resumablejs/./src/resumableEventHandler.ts","webpack://resumablejs/./src/resumableFile.ts","webpack://resumablejs/./src/resumableHelpers.ts","webpack://resumablejs/webpack/bootstrap","webpack://resumablejs/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"resumablejs\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"resumablejs\"] = factory();\n\telse\n\t\troot[\"resumablejs\"] = factory();\n})(this, function() {\nreturn ","import Helpers from './resumableHelpers';\nimport ResumableFile from './resumableFile';\nimport ResumableEventHandler from './resumableEventHandler';\nimport {ExtendedFile, ResumableChunkStatus, ResumableConfiguration} from './types/types';\n\n/*\n* MIT Licensed\n* http://www.twentythree.com/\n* http://github.com/23/resumable.js\n* Steffen Tiedemann Christensen, steffen@twentythree.com\n*/\n\n/**\n * An instance of a resumable upload handler that contains one or multiple files which should be uploaded in chunks.\n */\nexport class Resumable extends ResumableEventHandler {\n  private opts: ResumableConfiguration;\n  /**\n   * An object that contains one entry for every file category. The key is the category name, the value is an array of\n   * all ResumableFiles of that category that were added to this instance.\n   */\n  private files: {[key: string]: ResumableFile[]} = {};\n  /**\n   * Contains all file categories for which the upload was not yet completed.\n   */\n  private uncompletedFileCategories: string[] = [];\n  private validators: {[fileType: string]: Function} = {};\n  private support: boolean;\n\n  // Configuration Options\n  clearInput: boolean = true;\n  dragOverClass: string = 'dragover';\n  fileCategories: string[] = [];\n  defaultFileCategory: string | null = 'default';\n  fileTypes: string[] | {[fileCategory: string]: string[]} = [];\n  fileTypeErrorCallback: Function = (file) => {\n    alert(`${file.fileName || file.name} has an unsupported file type.`);\n  };\n  _generateUniqueIdentifier: Function = null;\n  maxFileSize?: number;\n  maxFileSizeErrorCallback: Function = (file) => {\n    alert(file.fileName || file.name + ' is too large, please upload files less than ' +\n      Helpers.formatSize(this.maxFileSize) + '.');\n  };\n  maxFiles?: number;\n  maxFilesErrorCallback: Function = (files) => {\n    var maxFiles = this.maxFiles;\n    alert('Please upload no more than ' + maxFiles + ' file' + (maxFiles === 1 ? '' : 's') + ' at a time.');\n  };\n  minFileSize: number = 1;\n  minFileSizeErrorCallback: Function = (file) => {\n    alert(file.fileName || file.name + ' is too small, please upload files larger than ' +\n      Helpers.formatSize(this.minFileSize) + '.');\n  };\n  prioritizeFirstAndLastChunk: boolean = false;\n  fileValidationErrorCallback: Function = (file) => {};\n  simultaneousUploads: number = 3;\n\n  constructor(options: ResumableConfiguration = {}) {\n    super();\n    this.setInstanceProperties(options);\n    this.opts = options;\n    this.checkSupport();\n  }\n\n  /**\n   * Check whether the current browser supports the essential functions for the package to work.\n   * The method checks if these features are supported:\n   * - File object type\n   * - Blob object type\n   * - FileList object type\n   * - slicing files\n   */\n  private checkSupport(): void {\n    this.support =\n      File !== undefined &&\n      Blob !== undefined &&\n      FileList !== undefined &&\n      !!Blob.prototype.slice;\n    if (!this.support) {\n      throw new Error('Not supported by Browser');\n    }\n  }\n\n  /**\n   * Assign the attributes of this instance via destructuring of the options object.\n   */\n  protected setInstanceProperties(options: ResumableConfiguration) {\n    Object.assign(this, options);\n\n    // Explicitly test for null because other falsy values could be used as default.\n    if (this.defaultFileCategory === null) {\n      if (this.fileCategories.length === 0) {\n        throw new Error('If no default category is set, at least one file category must be defined.');\n      }\n    } else if (!this.fileCategories.includes(this.defaultFileCategory)) {\n      this.fileCategories.push(this.defaultFileCategory);\n    } else {\n      console.warn('Default file category already part of file categories array. Will not be added again.');\n    }\n\n    // To avoid any problems if the same category was added twice, we use the following loop to also deduplicate the\n    // file categories.\n    const deduplicatedFileCategories = [];\n    this.fileCategories.forEach((fileCategory) => {\n      if (this.files[fileCategory]) {\n        return;\n      }\n\n      this.files[fileCategory] = [];\n      this.uncompletedFileCategories.push(fileCategory);\n      deduplicatedFileCategories.push(fileCategory);\n    });\n\n    this.fileCategories = deduplicatedFileCategories.slice();\n\n    // Create/Check file types object.\n    if (Array.isArray(this.fileTypes)) {\n      // If fileTypes are given as an array, these types should be used for all file categores.\n      // Create the file types object and assign the given array to every file category.\n      const fileTypes = this.fileTypes.slice();\n\n      this.fileTypes = {};\n      this.fileCategories.forEach((fileCategory) => {\n        this.fileTypes[fileCategory] = fileTypes.slice();\n      });\n    } else {\n      const fileTypeCategories = Object.keys(this.fileTypes);\n      this.fileCategories.forEach((fileCategory) => {\n        if (!fileTypeCategories.includes(fileCategory)) {\n          console.warn('File category \"' + fileCategory + '\" not part of fileTypes object. Assuming empty array (which allows all file types).');\n        }\n\n        this.fileTypes[fileCategory] = [];\n      });\n    }\n\n    this.sanitizeFileTypes();\n  }\n\n  private sanitizeFileTypes(): void {\n    // For good behaviour we do some sanitizing. Remove spaces and dots and lowercase all.\n    Object.keys(this.fileTypes).forEach((fileCategory) => {\n      this.fileTypes[fileCategory] = this.fileTypes[fileCategory].map((type) => type.replace(/[\\s.]/g, '').toLowerCase());\n    });\n  }\n\n  private throwIfUnknownFileCategory(fileCategory: string): void {\n    if (!this.fileCategories.includes(fileCategory)) {\n      throw new Error('Unknown file category: ' + fileCategory);\n    }\n  }\n\n  /**\n   * Transforms a single fileEntry or directoryEntry item into a list of File objects this method is used to convert\n   * entries found inside dragged-and-dropped directories.\n   * @param {Object} item item to upload, may be file or directory entry\n   * @param {string} path current file path\n   */\n  private async mapDirectoryItemToFile(item: FileSystemEntry, path: string): Promise<File[]> {\n    if (item.isFile) {\n      // file entry provided\n      const file = await new Promise(\n        (resolve, reject) => (item as FileSystemFileEntry).file(resolve, reject)\n      ) as ExtendedFile;\n      file.relativePath = path + file.name;\n      return [file];\n    } else if (item.isDirectory) {\n      // directory entry provided\n      return await this.processDirectory(item as FileSystemDirectoryEntry, path + item.name + '/');\n    } else if (item instanceof File) {\n      return [item];\n    }\n\n    console.warn('Item mapping did not return a file object. This might be due to an unknown file type.')\n    return [];\n  }\n\n  /**\n   * Transforms a single DataTransfer item into a File object. This may include either extracting the given file or\n   * all files inside the provided directory.\n   * @param item item to upload, may be file or directory entry\n   * @param path current file path\n   */\n  private async mapDragItemToFile(item: DataTransferItem, path: string): Promise<File[]> {\n    let entry = item.webkitGetAsEntry();\n    if (entry.isDirectory) {\n      return await this.processDirectory(entry as FileSystemDirectoryEntry, path + entry.name + '/');\n    }\n\n    let file = item.getAsFile();\n    if (file instanceof File) {\n      (file as ExtendedFile).relativePath = path + file.name;\n      return [file];\n    }\n\n    console.warn('Item mapping did not return a file object. This might be due to an unknown file type.')\n    return [];\n  }\n\n  /**\n   * Recursively traverse a directory and collect files to upload\n   */\n  private processDirectory(directory: FileSystemDirectoryEntry, path: string): Promise<File[]> {\n    return new Promise((resolve, reject) => {\n      const dirReader = directory.createReader();\n      let allEntries = [];\n\n      const readEntries = (): void => {\n        dirReader.readEntries(async (entries: FileSystemEntry[]): Promise<void> => {\n          // Read the files batch-wise (in chrome e.g. 100 at a time)\n          if (entries.length) {\n            allEntries = allEntries.concat(entries);\n            return readEntries();\n          }\n\n          // After collecting all files, map all fileEntries to File objects\n          allEntries = allEntries.map((entry) => {\n            return this.mapDirectoryItemToFile(entry, path);\n          });\n          // Wait until all files are collected.\n          resolve(await Promise.all(allEntries));\n        }, reject);\n      };\n\n      readEntries();\n    });\n  }\n\n  /**\n   * If \"assignDrop\" was used to assign the drop events to an element, we automatically add the \"dragOverClass\" CSS\n   * class to the element when a file is dropped onto it. In this case, we have to remove that class again before\n   * calling \"onDrop()\".\n   * If \"onDrop()\" is called from \"handleDropEvent()\" this is not needed.\n   */\n  private removeDragOverClassAndCallOnDrop(e: DragEvent): Promise<void> {\n    const domNode: HTMLElement = e.currentTarget as HTMLElement;\n    domNode.classList.remove(this.dragOverClass);\n    const fileCategory = domNode.getAttribute('resumable-file-category');\n\n    this.throwIfUnknownFileCategory(fileCategory);\n\n    return this.onDrop(e, fileCategory);\n  }\n\n  /**\n   * Handle the event when a new file was provided via drag-and-drop\n   */\n  private async onDrop(e: DragEvent, fileCategory: string = this.defaultFileCategory): Promise<void> {\n    Helpers.stopEvent(e);\n\n    let items = [];\n\n    //handle dropped things as items if we can (this lets us deal with folders nicer in some cases)\n    if (e.dataTransfer && e.dataTransfer.items) {\n      items = [...e.dataTransfer.items as any];\n    }\n    //else handle them as files\n    else if (e.dataTransfer && e.dataTransfer.files) {\n      items =  [...e.dataTransfer.files as any];\n    }\n\n    if (!items.length) {\n      return; // nothing to do\n    }\n    this.fire('fileProcessingBegin', items, fileCategory);\n    let promises = items.map((item) => this.mapDragItemToFile(item, ''));\n    let files = Helpers.flattenDeep(await Promise.all(promises));\n    if (files.length) {\n      // at least one file found\n      this.appendFilesFromFileList(files, e, fileCategory);\n    }\n  }\n\n  /**\n   * Handle the event when a drag-and-drop item leaves the area of assigned drag-and-drop area\n   */\n  private onDragLeave(e: DragEvent): void {\n    (e.currentTarget as HTMLElement).classList.remove(this.dragOverClass);\n  }\n\n  /**\n   * Handle the event when a drag-and-drop item enters the area of assigned drag-and-drop area\n   */\n  private onDragOverEnter(e: DragEvent): void {\n    e.preventDefault();\n    let dt = e.dataTransfer;\n    if (dt.types.includes('Files')) { // only for file drop\n      e.stopPropagation();\n      dt.dropEffect = 'copy';\n      dt.effectAllowed = 'copy';\n      (e.currentTarget as HTMLElement).classList.add(this.dragOverClass);\n    } else {\n      dt.dropEffect = 'none';\n      dt.effectAllowed = 'none';\n    }\n  };\n\n  /**\n   * Validate and clean a list of files. This includes the removal of duplicates, a check whether the file type is\n   * allowed and custom validation functions defined per file type.\n   * @param {ExtendedFile[]} files A list of File instances that were previously extended with a uniqueIdentifier\n   * @param fileCategory The file category that has been provided for the files. Defaults to `defaultFileCategory`.\n   */\n  private async validateFiles(files: ExtendedFile[], fileCategory: string = this.defaultFileCategory): Promise<ExtendedFile[]> {\n    if (!this.fileCategories.includes(fileCategory)) {\n      this.fire('fileProcessingFailed', undefined, 'unknownFileCategory', fileCategory);\n      return;\n    }\n\n    // Remove files that are duplicated in the original array, based on their unique identifiers\n    let uniqueFiles = Helpers.uniqBy(files,\n      (file) => file.uniqueIdentifier,\n      (file) => this.fire('fileProcessingFailed', file, 'duplicate', fileCategory),\n    );\n\n    const resumableFiles = this.files[fileCategory];\n    let validationPromises = uniqueFiles.map(async (file) => {\n      // Check if the file has already been added (based on its unique identifier).\n      if (resumableFiles.some((addedFile) => addedFile.uniqueIdentifier === file.uniqueIdentifier)) {\n        this.fire('fileProcessingFailed', file, 'duplicate', fileCategory);\n        return false;\n      }\n\n      let fileType: string = file.type.toLowerCase();\n      let fileExtension = file.name.split('.').pop().toLowerCase();\n\n      if (this.fileTypes[fileCategory].length > 0) {\n        const fileTypeFound = this.fileTypes[fileCategory].some((type) => {\n          // Check whether the extension inside the filename is an allowed file type\n          return fileExtension === type ||\n            // If MIME type, check for wildcard or if extension matches the file's tile type\n            type.includes('/') && (\n              type.includes('*') &&\n              fileType.substring(0, type.indexOf('*')) === type.substring(0, type.indexOf('*')) ||\n              fileType === type\n            );\n        });\n        if (!fileTypeFound) {\n          this.fire('fileProcessingFailed', file, 'fileType', fileCategory);\n          this.fileTypeErrorCallback(file);\n          return false;\n        }\n      }\n\n      // Validate the file size against minimum and maximum allowed sizes\n      if (this.minFileSize !== undefined && file.size < this.minFileSize) {\n        this.fire('fileProcessingFailed', file, 'minFileSize', fileCategory);\n        this.minFileSizeErrorCallback(file);\n        return false;\n      }\n      if (this.maxFileSize !== undefined && file.size > this.maxFileSize) {\n        this.fire('fileProcessingFailed', file, 'maxFileSize', fileCategory);\n        this.maxFileSizeErrorCallback(file);\n        return false;\n      }\n\n      // Apply a custom validator based on the file extension\n      if (fileExtension in this.validators && !await this.validators[fileExtension](file, fileCategory)) {\n        this.fire('fileProcessingFailed', file, 'validation', fileCategory);\n        this.fileValidationErrorCallback(file);\n        return false;\n      }\n\n      return true;\n    });\n\n    const results = await Promise.all(validationPromises);\n\n    // Only include files that passed their validation tests\n    return files.filter((_v, index) => results[index]);\n  }\n\n  /**\n   * Add an array of files to this instance's file list (of the file category, if given) by creating new ResumableFiles.\n   * This includes a validation and deduplication of the provided array.\n   * @param fileList An array containing File objects\n   * @param event The event with which the fileList was provided\n   * @param fileCategory The file category that has been provided for the file. Defaults to `defaultFileCategory`.\n   */\n  private async appendFilesFromFileList(fileList: File[], event: Event, fileCategory: string = this.defaultFileCategory): Promise<boolean> {\n    const resumableFiles = this.files[fileCategory];\n\n    if (!resumableFiles) {\n      this.fire('fileProcessingFailed', undefined, 'unknownFileCategory', fileCategory);\n      return false;\n    }\n\n    const allResumableFiles = this.getFilesOfAllCategories();\n\n    // check for uploading too many files\n    if (this.maxFiles !== undefined && this.maxFiles < fileList.length + allResumableFiles.length) {\n      // if single-file upload, file is already added, and trying to add 1 new file, simply replace the already-added file\n      if (this.maxFiles === 1 && allResumableFiles.length === 1 && fileList.length === 1) {\n        this.removeFile(resumableFiles[0]);\n      } else {\n        this.fire('fileProcessingFailed', undefined, 'maxFiles', fileCategory);\n        this.maxFilesErrorCallback(fileList);\n        return false;\n      }\n    }\n\n    // Add the unique identifier for every new file.\n    // Since this might return a promise, we have to wait until it completed.\n    const filesWithUniqueIdentifiers = await Promise.all(fileList.map(async (file: ExtendedFile): Promise<ExtendedFile> => {\n      file.uniqueIdentifier = await this.generateUniqueIdentifier(file, event, fileCategory);\n      return file;\n    }));\n\n    // Validate the files and remove duplicates\n    const validatedFiles = await this.validateFiles(filesWithUniqueIdentifiers, fileCategory);\n\n    let skippedFiles = filesWithUniqueIdentifiers.filter((file) => !validatedFiles.includes(file));\n\n    for (const file of validatedFiles) {\n      let f = new ResumableFile(file, file.uniqueIdentifier, fileCategory, this.opts);\n      f.on('chunkSuccess', () => this.handleChunkSuccess());\n      f.on('chunkError', () => this.handleChunkError());\n      f.on('chunkCancel', () => this.handleChunkCancel());\n      f.on('fileProgress', (...args) => this.handleFileProgress(args, fileCategory));\n      f.on('fileError', (...args) => this.handleFileError(args, fileCategory));\n      f.on('fileSuccess', (...args) => this.handleFileSuccess(args, fileCategory));\n      f.on('fileCancel', (...args) => this.handleFileCancel(args));\n      f.on('fileRetry', () => this.handleFileRetry());\n      this.files[fileCategory].push(f);\n      this.fire('fileAdded', f, event, fileCategory);\n    }\n\n    // all files processed, trigger event\n    if (!validatedFiles.length && !skippedFiles.length) {\n      // no succeeded files, just skip\n      return;\n    }\n    this.fire('filesAdded', validatedFiles, skippedFiles, fileCategory);\n  }\n\n  /**\n   * Generate a new unique identifier for a given file either with a default helper function or with a custom\n   * generator function.\n   * @param file The file as an HTML 5 File object\n   * @param event The event with which the file was provided originally\n   * @param fileCategory The file category that has been provided for the file. Defaults to `defaultFileCategory`.\n   */\n  private generateUniqueIdentifier(file: File, event: Event, fileCategory: string = this.defaultFileCategory): string {\n    return typeof this._generateUniqueIdentifier === 'function' ?\n      this._generateUniqueIdentifier(file, event, fileCategory) : Helpers.generateUniqueIdentifier(file);\n  }\n\n  /**\n   * Queue a new chunk to be uploaded that is currently awaiting upload.\n   */\n  private uploadNextChunk(): void {\n    const allResumableFiles = this.getFilesOfAllCategories();\n\n    // In some cases (such as videos) it's really handy to upload the first\n    // and last chunk of a file quickly; this lets the server check the file's\n    // metadata and determine if there's even a point in continuing.\n    if (this.prioritizeFirstAndLastChunk) {\n      for (const file of allResumableFiles) {\n        if (file.chunks.length && file.chunks[0].status === ResumableChunkStatus.PENDING) {\n          file.chunks[0].send();\n          return;\n        }\n        if (file.chunks.length > 1 && file.chunks[file.chunks.length - 1].status === ResumableChunkStatus.PENDING) {\n          file.chunks[file.chunks.length - 1].send();\n          return;\n        }\n      }\n    }\n\n    // Now, simply look for the next best thing to upload\n    for (const file of allResumableFiles) {\n      if (file.upload()) return;\n    }\n  }\n\n  /**\n   * Returns all ResumableFiles of all file categories.\n   * The files are ordered by the order of the file categories in `this.fileCategories`. Files of the first category\n   * are added first, files of the second category are added second etc.\n   *\n   * @returns {ResumableFile[]} Array of all ResumableFiles that are stored for any category.\n   */\n  private getFilesOfAllCategories(): ResumableFile[] {\n    let allFiles = [];\n\n    this.fileCategories.forEach((fileCategory) => {\n      allFiles = allFiles.concat(this.files[fileCategory]);\n    });\n\n    return allFiles;\n  }\n\n  /**\n   *  PUBLIC METHODS FOR RESUMABLE.JS\n   *  This section only includes methods that should be callable from external packages.\n   */\n\n  /**\n   * Assign a browse action to one or more DOM nodes. Pass in true to allow directories to be selected (Chrome only).\n   *\n   * @param domNodes The dom nodes to which the browse action should be assigned (can be an array or a single dom node).\n   * @param isDirectory If true, directories can be added via the file picker (Chrome only).\n   * @param fileCategory The file category that will be assigned to all added files. Defaults to `defaultFileCategory`.\n   */\n  assignBrowse(domNodes: HTMLElement | HTMLElement[], isDirectory: boolean = false, fileCategory: string = this.defaultFileCategory): void {\n    this.throwIfUnknownFileCategory(fileCategory);\n\n    if (domNodes instanceof HTMLElement) domNodes = [domNodes];\n    for (const domNode of domNodes) {\n      let input;\n      if (domNode instanceof HTMLInputElement && domNode.type === 'file') {\n        input = domNode;\n      } else {\n        input = document.createElement('input');\n        input.setAttribute('type', 'file');\n        input.style.display = 'none';\n        domNode.addEventListener('click', () => {\n          input.style.opacity = 0;\n          input.style.display = 'block';\n          input.focus();\n          input.click();\n          input.style.display = 'none';\n        }, false);\n        domNode.appendChild(input);\n      }\n      if (this.maxFiles !== 1) {\n        input.setAttribute('multiple', 'multiple');\n      } else {\n        input.removeAttribute('multiple');\n      }\n      if (isDirectory) {\n        input.setAttribute('webkitdirectory', 'webkitdirectory');\n      } else {\n        input.removeAttribute('webkitdirectory');\n      }\n\n      // Call setFileTypes() without changing the file types to just update the file types which are accepted by the\n      // input dom element.\n      this.setFileTypes(this.fileTypes[fileCategory], input, fileCategory);\n\n      input.addEventListener(\n        'change',\n        (event: InputEvent) => {\n          this.handleChangeEvent(event, fileCategory);\n        },\n        false\n      );\n    }\n  }\n\n  /**\n   * Assign one or more DOM nodes as a drop target.\n   *\n   * @param domNodes The dom nodes to which the drop action should be assigned (can be an array or a single dom node).\n   * @param fileCategory The file category that will be assigned to all added files. Defaults to `defaultFileCategory`. \n   */\n  assignDrop(domNodes: HTMLElement | HTMLElement[], fileCategory: string = this.defaultFileCategory): void {\n    this.throwIfUnknownFileCategory(fileCategory);\n\n    if (domNodes instanceof HTMLElement) domNodes = [domNodes];\n\n    for (const domNode of domNodes) {\n      if (fileCategory) {\n        // Assign the file category as attribute to the Dom node. This is needed because this information needs to be read\n        // in the \"drop\" event listener, but we can't pass a value into the listener directly. Unfortunately we can't use\n        // an arrow function as a wrapper here (as done in assignBrowse()) because we need to be able to access the same\n        // function in unAssignDrop().\n        domNode.setAttribute('resumable-file-category', fileCategory);\n      }\n\n      domNode.addEventListener('dragover', this.onDragOverEnter.bind(this), false);\n      domNode.addEventListener('dragenter', this.onDragOverEnter.bind(this), false);\n      domNode.addEventListener('dragleave', this.onDragLeave.bind(this), false);\n      domNode.addEventListener('drop', this.removeDragOverClassAndCallOnDrop.bind(this), false);\n    }\n  }\n\n  /**\n   * Remove one or more DOM nodes as a drop target.\n   */\n  unAssignDrop(domNodes: HTMLElement | HTMLElement[]): void {\n    if (domNodes instanceof HTMLElement) domNodes = [domNodes];\n\n    for (const domNode of domNodes) {\n      domNode.removeEventListener('dragover', this.onDragOverEnter.bind(this));\n      domNode.removeEventListener('dragenter', this.onDragOverEnter.bind(this));\n      domNode.removeEventListener('dragleave', this.onDragLeave.bind(this));\n      domNode.removeEventListener('drop', this.removeDragOverClassAndCallOnDrop.bind(this));\n    }\n  }\n\n  /**\n   * Set the file types allowed to upload.\n   * Per default the file types are updated for the default file category.\n   * Optionally pass a dom node on which the accepted file types should be updated as well.\n   *\n   * @param fileTypes String array of all allowed file types\n   * @param domNode An optional HTMLInputElement for which the \"accepted\" attribute should be updated accordingly.\n   * @param fileCategory The file category for which the file types should be updated. Defaults to `defaultFileCategory`.\n   */\n  setFileTypes(fileTypes: string[], domNode: HTMLInputElement = null, fileCategory: string = this.defaultFileCategory): void {\n    this.throwIfUnknownFileCategory(fileCategory);\n\n    if (domNode && domNode.type !== 'file') {\n      throw new Error('Dom node is not a file input.');\n    }\n\n    // Store new file types and sanitize them.\n    this.fileTypes[fileCategory] = fileTypes;\n    this.sanitizeFileTypes();\n\n    if (domNode) {\n      if (fileTypes.length >= 1) {\n        // Set the new file types as \"accepted\" by the given dom node.\n        domNode.setAttribute('accept', this.fileTypes[fileCategory].map((type) => {\n          if (type.match(/^[^.][^/]+$/)) {\n            type = '.' + type;\n          }\n          return type;\n        }).join(','));\n      } else {\n        // Make all file types \"accepted\" by the given dom node.\n        domNode.removeAttribute('accept');\n      }\n    }\n  }\n\n  /**\n   * Check whether any files are currently uploading\n   */\n  get isUploading(): boolean {\n    return this.getFilesOfAllCategories().some((file) => file.isUploading);\n  }\n\n  /**\n   * Start or resume the upload of the provided files by initiating the upload of the first chunk\n   */\n  upload(): void {\n    // Make sure we don't start too many uploads at once\n    if (this.isUploading) return;\n    // Kick off the queue\n    this.fire('uploadStart');\n    for (let num = 1; num <= this.simultaneousUploads; num++) {\n      this.uploadNextChunk();\n    }\n  }\n\n  /**\n   * Pause the upload\n   */\n  pause(): void {\n    // Resume all chunks currently being uploaded\n    for (const file of this.getFilesOfAllCategories()) {\n      file.abort();\n    }\n    this.fire('pause');\n  };\n\n  /**\n   * Cancel uploading and reset all files to their initial states\n   */\n  cancel(): void {\n    this.fire('beforeCancel');\n    const allFiles = this.getFilesOfAllCategories();\n    allFiles.forEach((file) => {\n      file.cancel();\n    });\n\n    this.fire('cancel');\n  };\n\n  /**\n   * Return the progress of the current upload as a float between 0 and 1\n   */\n  progress(): number {\n    let totalDone = this.getFilesOfAllCategories().reduce((accumulator, file) => accumulator + file.size * file.progress(), 0);\n    let totalSize = this.getSize();\n    return totalSize > 0 ? totalDone / totalSize : 0;\n  };\n\n  /**\n   * Add a HTML5 File object to the list of files.\n   */\n  addFile(file: File, event: Event, fileCategory: string = this.defaultFileCategory): void {\n    this.throwIfUnknownFileCategory(fileCategory);\n\n    this.appendFilesFromFileList([file], event, fileCategory);\n  };\n\n  /**\n   * Add a list of HTML5 File objects to the list of files.\n   */\n  addFiles(files: File[], event: Event, fileCategory: string = this.defaultFileCategory): void {\n    this.throwIfUnknownFileCategory(fileCategory);\n\n    this.appendFilesFromFileList(files, event, fileCategory);\n  };\n\n  /**\n   * Add a validator function for the given file type. This can e.g. be used to read the file and validate\n   * checksums based on certain properties.\n   * @param fileType The file extension for the given validator\n   * @param validator A callback function that should be called when validating files with the given type\n   */\n  addFileValidator(fileType: string, validator: Function): void {\n    if (fileType in this.validators) {\n      console.warn(`Overwriting validator for file type: ${fileType}`);\n    }\n    this.validators[fileType] = validator;\n  }\n\n  /**\n   * Remove the given resumable file from the file list (of its corresponding file category).\n   */\n  removeFile(file: ResumableFile): void {\n    const fileCategory = file.fileCategory;\n    const fileIndex = this.files[fileCategory].findIndex(\n      (fileFromArray) => fileFromArray.uniqueIdentifier === file.uniqueIdentifier\n    );\n\n    if (fileIndex >= 0) {\n      this.files[fileCategory].splice(fileIndex, 1);\n    }\n  };\n\n  /**\n   * Retrieve a ResumableFile object from the file list by its unique identifier.\n   */\n  getFromUniqueIdentifier(uniqueIdentifier: string): ResumableFile {\n    return this.getFilesOfAllCategories().find((file) => file.uniqueIdentifier === uniqueIdentifier);\n  };\n\n  /**\n   * Get the combined size of all files for the upload\n   */\n  getSize(): number {\n    return this.getFilesOfAllCategories().reduce((accumulator, file) => accumulator + file.size, 0);\n  }\n\n  /**\n   * Call the event handler for a DragEvent (when a file is dropped on a drop area).\n   */\n  handleDropEvent(e: DragEvent, fileCategory: string = this.defaultFileCategory): void {\n    this.throwIfUnknownFileCategory(fileCategory);\n\n    this.onDrop(e, fileCategory);\n  }\n\n  /**\n   * Call the event handler for an InputEvent (i.e. received one or multiple files).\n   */\n  handleChangeEvent(e: InputEvent, fileCategory: string = this.defaultFileCategory): void {\n    this.throwIfUnknownFileCategory(fileCategory);\n\n    const eventTarget = e.target as HTMLInputElement;\n    this.fire('fileProcessingBegin', eventTarget.files, fileCategory);\n    this.appendFilesFromFileList([...eventTarget.files as any], e, fileCategory);\n    if (this.clearInput) {\n      eventTarget.value = '';\n    }\n  }\n\n  /**\n   * Check whether the upload is completed (if all files of a category are uploaded and if all files in general are\n   * uploaded).\n   */\n  checkUploadComplete(): void {\n    // If no files were added, there is no upload that could be complete.\n    if (this.getFilesOfAllCategories().length === 0) {\n      return;\n    }\n\n    const stillUncompletedFileCategories = [];\n    this.uncompletedFileCategories.forEach((fileCategory) => {\n      // If category is empty, no upload will happen, so no \"complete\" event needs to be fired.\n      if (this.files[fileCategory].length == 0) {\n        return;\n      }\n\n      if (this.files[fileCategory].every((file) => file.isComplete)) {\n        this.fire('categoryComplete', fileCategory);\n      } else {\n        stillUncompletedFileCategories.push(fileCategory);\n      }\n    });\n\n    this.uncompletedFileCategories = stillUncompletedFileCategories;\n\n    if (this.uncompletedFileCategories.length === 0) {\n      // All chunks have been uploaded, complete\n      this.fire('complete');\n    }\n  }\n\n  /**\n   * Event Handlers: This section should only include methods that are used to\n   * handle events coming from the files or chunks.\n   */\n\n  /**\n   * The event handler when a chunk was uploaded successfully\n   */\n  private handleChunkSuccess(): void {\n    this.uploadNextChunk();\n  }\n\n  /**\n   * The event handler when a chunk was uploaded successfully\n   */\n  private handleChunkError(): void {\n    this.uploadNextChunk();\n  }\n\n  /**\n   * The event handler when an error occurred during the upload of a chunk\n   */\n  private handleChunkCancel(): void {\n    this.uploadNextChunk();\n  }\n\n  /**\n   * The event handler when an error occurred during the upload of a file\n   */\n  private handleFileError(args: any[], fileCategory: string): void {\n    this.fire('error', args[1], args[0], fileCategory);\n  }\n\n  /**\n   * The event handler when all chunks from a file were uploaded successfully\n   */\n  private handleFileSuccess(args: any[], fileCategory: string): void {\n    this.fire('fileSuccess', ...args, fileCategory);\n    this.checkUploadComplete();\n  }\n\n  /**\n   * The event handler when a file progress event was received\n   */\n  private handleFileProgress(args: any[], fileCategory: string): void {\n    this.fire('fileProgress', ...args, fileCategory);\n    this.fire('progress');\n  }\n\n  /**\n   * The event handler when the upload of a file was canceled\n   */\n  private handleFileCancel(args: any[]): void {\n    this.removeFile(args[0])\n  }\n\n  /**\n   * The event handler, when the retry of a file was initiated\n   */\n  private handleFileRetry(): void {\n    this.upload();\n  }\n}\n","import Helpers from './resumableHelpers';\nimport ResumableEventHandler from './resumableEventHandler';\nimport ResumableFile from './resumableFile';\nimport {ResumableChunkStatus, ResumableConfiguration} from './types/types';\n\n/**\n * A file chunk that contains all the data that for a single upload request\n */\nexport default class ResumableChunk extends ResumableEventHandler {\n  private fileObj: ResumableFile;\n  private fileObjSize: number;\n  private fileObjType: string;\n  private offset: number;\n  private lastProgressCallback: Date = new Date;\n  private tested: boolean = false;\n  private retries: number = 0;\n  private pendingRetry: boolean = false;\n  private isMarkedComplete: boolean = false;\n  private loaded: number = 0;\n  private startByte: number;\n  private endByte: number;\n  private xhr: XMLHttpRequest = null;\n\n  // Option properties\n  private chunkSize: number = 1024 * 1024; // 1 MB\n  private fileParameterName: string = 'file';\n  chunkNumberParameterName: string = 'resumableChunkNumber';\n  chunkSizeParameterName: string = 'resumableChunkSize';\n  currentChunkSizeParameterName: string = 'resumableCurrentChunkSize';\n  totalSizeParameterName: string = 'resumableTotalSize';\n  typeParameterName: string = 'resumableType';\n  identifierParameterName: string = 'resumableIdentifier';\n  fileCategoryParameterName: string = 'resumableFileCategory';\n  fileNameParameterName: string = 'resumableFilename';\n  relativePathParameterName: string = 'resumableRelativePath';\n  totalChunksParameterName: string = 'resumableTotalChunks';\n  throttleProgressCallbacks: number = 0.5;\n  query: object = {};\n  headers: object = {};\n  method: string = 'multipart';\n  uploadMethod: string = 'POST';\n  testMethod: string = 'GET';\n  parameterNamespace: string = '';\n  testChunks: boolean = true;\n  maxChunkRetries: number = 100;\n  chunkRetryInterval?: number = undefined;\n  permanentErrors: number[] = [400, 401, 403, 404, 409, 415, 500, 501];\n  withCredentials: boolean = false;\n  xhrTimeout: number = 0;\n  chunkFormat: string = 'blob';\n  setChunkTypeFromFile: boolean = false;\n  target: string = '/';\n  testTarget: string = '';\n\n\n  constructor(fileObj: ResumableFile, offset: number, options: ResumableConfiguration) {\n    super();\n    this.setInstanceProperties(options);\n    this.fileObj = fileObj;\n    this.fileObjSize = fileObj.size;\n    this.fileObjType = fileObj.file.type;\n    this.offset = offset;\n\n    // Computed properties\n    this.startByte = this.offset * this.chunkSize;\n    this.endByte = Math.min(this.fileObjSize, (this.offset + 1) * this.chunkSize);\n    this.xhr = null;\n  }\n\n  /**\n   * Set the options provided inside the configuration object on this instance\n   */\n  protected setInstanceProperties(options: ResumableConfiguration): void {\n    Object.assign(this, options);\n  }\n\n  /**\n   * Set the header values for the current XMLHttpRequest\n   */\n  setCustomHeaders(): void {\n    if (!this.xhr) {\n      return;\n    }\n    let customHeaders = this.headers;\n    if (customHeaders instanceof Function) {\n      customHeaders = customHeaders(this.fileObj, this);\n    }\n    for (const header in customHeaders) {\n      if (!customHeaders.hasOwnProperty(header)) continue;\n      this.xhr.setRequestHeader(header, customHeaders[header]);\n    }\n  }\n\n  /**\n   * Get query parameters for this chunk as an object, combined with custom parameters if provided\n   */\n  get formattedQuery(): object {\n    var customQuery = this.query;\n    if (typeof customQuery == 'function') customQuery = customQuery(this.fileObj, this);\n\n    // Add extra data to identify chunk\n    const extraData = {\n      // define key/value pairs for additional parameters\n      [this.chunkNumberParameterName]: this.offset + 1,\n      [this.chunkSizeParameterName]: this.chunkSize,\n      [this.currentChunkSizeParameterName]: this.endByte - this.startByte,\n      [this.totalSizeParameterName]: this.fileObjSize,\n      [this.typeParameterName]: this.fileObjType,\n      [this.identifierParameterName]: this.fileObj.uniqueIdentifier,\n      [this.fileCategoryParameterName]: this.fileObj.fileCategory,\n      [this.fileNameParameterName]: this.fileObj.fileName,\n      [this.relativePathParameterName]: this.fileObj.relativePath,\n      [this.totalChunksParameterName]: this.fileObj.chunks.length,\n    };\n    return {...extraData, ...customQuery};\n  }\n\n  /**\n   * Determine the status for this Chunk based on different parameters of the underlying XMLHttpRequest\n   */\n  get status(): ResumableChunkStatus {\n    if (this.pendingRetry) {\n      // if pending retry then that's effectively the same as actively uploading,\n      // there might just be a slight delay before the retry starts\n      return ResumableChunkStatus.UPLOADING;\n    } else if (this.isMarkedComplete) {\n      return ResumableChunkStatus.SUCCESS;\n    } else if (!this.xhr) {\n      return ResumableChunkStatus.PENDING;\n    } else if (this.xhr.readyState < 4) {\n      // Status is really 'OPENED', 'HEADERS_RECEIVED' or 'LOADING' - meaning that stuff is happening\n      return ResumableChunkStatus.UPLOADING;\n    } else if (this.xhr.status === 200 || this.xhr.status === 201) {\n      // HTTP 200, 201 (created)\n      return ResumableChunkStatus.SUCCESS;\n    } else if (this.permanentErrors.includes(this.xhr.status) || this.retries >= this.maxChunkRetries) {\n      // HTTP 400, 404, 409, 415, 500, 501 (permanent error)\n      return ResumableChunkStatus.ERROR;\n    } else {\n      // this should never happen, but we'll reset and queue a retry\n      // a likely case for this would be 503 service unavailable\n      this.abort();\n      return ResumableChunkStatus.PENDING;\n    }\n  };\n\n  /**\n   * Get the target url for the specified request type and the configured parameters of this chunk\n   * @param requestType The type of the request, either 'test' or 'upload'\n   */\n  getTarget(requestType: string): string {\n    return Helpers.getTarget(requestType, this.target, this.testTarget, this.formattedQuery, this.parameterNamespace);\n  }\n\n  /**\n   * Makes a GET request without any data to see if the chunk has already been uploaded in a previous session\n   */\n  test(): void {\n    // Set up request and listen for event\n    this.xhr = new XMLHttpRequest();\n\n    var testHandler = () => {\n      this.tested = true;\n      var status = this.status;\n      if (status === ResumableChunkStatus.SUCCESS) {\n        this.fire('chunkSuccess', this.message());\n      } else {\n        this.send();\n      }\n    };\n    this.xhr.addEventListener('load', testHandler, false);\n    this.xhr.addEventListener('error', testHandler, false);\n    this.xhr.addEventListener('timeout', testHandler, false);\n\n    // Append the relevant chunk and send it\n    this.xhr.open(this.testMethod, this.getTarget('test'));\n    this.xhr.timeout = this.xhrTimeout;\n    this.xhr.withCredentials = this.withCredentials;\n    // Add data from header options\n    this.setCustomHeaders();\n\n    this.xhr.send(null);\n  }\n\n  /**\n   * Abort and reset a request\n   */\n  abort(): void {\n    if (this.xhr) this.xhr.abort();\n    this.xhr = null;\n  }\n\n  /**\n   *  Uploads the actual data in a POST call\n   */\n  send(): void {\n    if (this.testChunks && !this.tested) {\n      this.test();\n      return;\n    }\n\n    // Set up request and listen for event\n    this.xhr = new XMLHttpRequest();\n\n    // Progress\n    this.xhr.upload.addEventListener('progress', (e: ProgressEvent<XMLHttpRequestEventTarget>) => {\n      if (Date.now() - this.lastProgressCallback.getTime() > this.throttleProgressCallbacks * 1000) {\n        this.fire('chunkProgress');\n        this.lastProgressCallback = new Date();\n      }\n      this.loaded = e.loaded || 0;\n    }, false);\n    this.loaded = 0;\n    this.pendingRetry = false;\n    this.fire('chunkProgress');\n\n    /**\n     * Handles the different xhr events based on the status of this chunk\n     */\n    let doneHandler = () => {\n      var status = this.status;\n      switch (status) {\n        case ResumableChunkStatus.SUCCESS:\n        case ResumableChunkStatus.ERROR:\n          this.fire(status, this.message());\n          break;\n        default:\n          this.fire('chunkRetry', this.message());\n          this.abort();\n          this.retries++;\n          let retryInterval = this.chunkRetryInterval;\n          if (retryInterval !== undefined) {\n            this.pendingRetry = true;\n            setTimeout(this.send, retryInterval);\n          } else {\n            this.send();\n          }\n          break;\n      }\n    };\n    this.xhr.addEventListener('load', doneHandler, false);\n    this.xhr.addEventListener('error', doneHandler, false);\n    this.xhr.addEventListener('timeout', doneHandler, false);\n\n    // Set up the basic query data from Resumable\n    let bytes = this.fileObj.file.slice(this.startByte, this.endByte,\n      this.setChunkTypeFromFile ? this.fileObj.file.type : '');\n    let data = null;\n    let parameterNamespace = this.parameterNamespace;\n    // Add data from the query options\n    if (this.method === 'octet') {\n      data = bytes;\n    } else {\n      data = new FormData();\n      for (const queryKey in this.formattedQuery) {\n        data.append(parameterNamespace + queryKey, this.formattedQuery[queryKey]);\n      }\n      switch (this.chunkFormat) {\n        case 'blob':\n          data.append(parameterNamespace + this.fileParameterName, bytes, this.fileObj.fileName);\n          break;\n        case 'base64':\n          var fr = new FileReader();\n          fr.onload = () => {\n            data.append(parameterNamespace + this.fileParameterName, fr.result);\n            this.xhr.send(data);\n          };\n          fr.readAsDataURL(bytes);\n          break;\n      }\n    }\n\n    let target = this.getTarget('upload');\n\n    this.xhr.open(this.uploadMethod, target);\n    if (this.method === 'octet') {\n      this.xhr.setRequestHeader('Content-Type', 'application/octet-stream');\n    }\n    this.xhr.timeout = this.xhrTimeout;\n    this.xhr.withCredentials = this.withCredentials;\n    // Add data from header options\n    this.setCustomHeaders();\n\n    if (this.chunkFormat === 'blob') {\n      this.xhr.send(data);\n    }\n  }\n\n  /**\n   * Return the response text of the underlying XMLHttpRequest if it exists\n   */\n  message(): string {\n    return this.xhr ? this.xhr.responseText : '';\n  };\n\n  /**\n   * Return the progress for the current chunk as a number between 0 and 1\n   * @param relative Whether or not the progress should be calculated based on the size of the entire file\n   */\n  progress(relative: boolean = false): number {\n    var factor = relative ? (this.endByte - this.startByte) / this.fileObjSize : 1;\n    if (this.pendingRetry) return 0;\n    if ((!this.xhr || !this.xhr.status) && !this.isMarkedComplete) factor *= .95;\n    switch (this.status) {\n      case ResumableChunkStatus.SUCCESS:\n      case ResumableChunkStatus.ERROR:\n        return factor;\n      case ResumableChunkStatus.PENDING:\n        return 0;\n      default:\n        return this.loaded / (this.endByte - this.startByte) * factor;\n    }\n  }\n\n  /**\n   * Mark this chunk as completed because it was already uploaded to the server.\n   */\n  markComplete(): void {\n    this.isMarkedComplete = true;\n  }\n}\n","/**\n * The underlying base class for ResumableJS. This class is responsible for registering and executing\n * events and listeners.\n */\nexport default class ResumableEventHandler {\n  private registeredEventHandlers: { [event: string]: Function[]};\n\n  /**\n   * Construct a new event handler instance.\n   */\n  constructor() {\n    this.registeredEventHandlers = {};\n  }\n\n  /**\n   * Register a new callback for the given event.\n   */\n  on(event: string, callback: Function): void {\n    event = event.toLowerCase();\n    if (!this.registeredEventHandlers.hasOwnProperty(event)) {\n      this.registeredEventHandlers[event] = [];\n    }\n    this.registeredEventHandlers[event].push(callback);\n  }\n\n  /**\n   * Fire the event listeners for the given event with the given arguments as well as the wildcard event '*'\n   */\n  fire(event: string, ...args): void {\n    event = event.toLowerCase();\n\n    this.executeEventCallback(event, ...args);\n    this.executeEventCallback('*', event, ...args);\n  }\n\n  /**\n   * Execute all callbacks for the given event with the provided arguments. This function is only used internally\n   * to call all callbacks registered to a given event individually.\n   */\n  private executeEventCallback(event: string, ...args): void {\n    if (!this.registeredEventHandlers.hasOwnProperty(event)) return;\n    this.registeredEventHandlers[event].forEach((callback) => callback(...args));\n  }\n}\n","import ResumableChunk from './resumableChunk';\nimport Helpers from './resumableHelpers';\nimport ResumableEventHandler from './resumableEventHandler';\nimport {ResumableChunkStatus, ResumableConfiguration} from './types/types';\n\n/**\n * A single file object that should be uploaded in multiple chunks\n */\nexport default class ResumableFile extends ResumableEventHandler {\n  private opts: ResumableConfiguration;\n  private _prevProgress: number = 0;\n  private isPaused: boolean = false;\n\n  file: File;\n  fileName: string;\n  size: number;\n  relativePath: string;\n  uniqueIdentifier: string;\n  fileCategory: string;\n  private _error: boolean;\n  chunks: ResumableChunk[] = [];\n  private chunkSize: number = 1024 * 1024; // 1 MB\n\n  constructor(file: File, uniqueIdentifier: string, fileCategory: string, options: object) {\n    super();\n    this.opts = options;\n    this.setInstanceProperties(options);\n    this.file = file;\n    this.fileName = file.name;\n    this.size = file.size;\n    this.relativePath = file.webkitRelativePath || this.fileName;\n    this.uniqueIdentifier = uniqueIdentifier;\n    this.fileCategory = fileCategory;\n    this._error = uniqueIdentifier !== undefined;\n\n    // Bootstrap file\n    this.fire('chunkingStart', this);\n    this.bootstrap();\n  }\n\n  /**\n   * Set the options provided inside the configuration object on this instance\n   */\n  protected setInstanceProperties(options: ResumableConfiguration) {\n    Object.assign(this, options);\n  }\n\n  /**\n   * Stop current uploads for this file\n   */\n  abort(): void {\n    let abortCount = 0;\n    for (const chunk of this.chunks) {\n      if (chunk.status === ResumableChunkStatus.UPLOADING) {\n        chunk.abort();\n        abortCount++;\n      }\n    }\n    if (abortCount > 0) this.fire('fileProgress', this, null);\n  }\n\n  /**\n   * Cancel uploading this file and remove it from the file list\n   */\n  cancel(): void {\n    for (const chunk of this.chunks) {\n      if (chunk.status === ResumableChunkStatus.UPLOADING) {\n        chunk.abort();\n        this.fire('chunkCancel', chunk);\n      }\n    }\n    // Reset this file to be void\n    this.chunks = [];\n    this.fire('fileCancel', this);\n    this.fire('fileProgress', this, null);\n  }\n\n  /**\n   * Retry uploading this file\n   */\n  retry(): void {\n    this.bootstrap();\n    let firedRetry = false;\n    this.on('chunkingComplete', () => {\n      if (!firedRetry) this.fire('fileRetry');\n      firedRetry = true;\n    });\n  }\n\n  /**\n   * Prepare this file for a new upload, by dividing it into multiple chunks\n   */\n  bootstrap(): void {\n    const progressHandler = (message) => this.fire('fileProgress', this, message);\n    const retryHandler = () =>  this.fire('fileRetry', this);\n    const successHandler = (message) => {\n      if (this._error) return;\n      this.fire('chunkSuccess');\n      this.fire('fileProgress', this, message); // it's at least progress\n      if (this.isComplete) {\n        this.fire('fileSuccess', this, message);\n      }\n    };\n    const errorHandler = (message) => {\n      this.fire('chunkError', message);\n      this.abort();\n      this._error = true;\n      this.chunks = [];\n      this.fire('fileError', this, message);\n    }\n\n    this.abort();\n    this._error = false;\n    // Rebuild stack of chunks from file\n    this.chunks = [];\n    this._prevProgress = 0;\n    const maxOffset = Math.max(Math.ceil(this.file.size / this.chunkSize), 1);\n    for (var offset = 0; offset < maxOffset; offset++) {\n      const chunk = new ResumableChunk(this, offset, this.opts);\n      chunk.on('chunkProgress', progressHandler);\n      chunk.on('chunkError', errorHandler);\n      chunk.on('chunkSuccess', successHandler);\n      chunk.on('chunkRetry', retryHandler);\n      this.chunks.push(chunk);\n      this.fire('chunkingProgress', this, offset / maxOffset);\n    }\n    this.fire('chunkingComplete', this);\n  }\n\n  /**\n   * Get the progress for uploading this file based on the progress of the individual file chunks\n   */\n  progress(): number {\n    if (this._error) return 1;\n    // Sum up progress across everything\n    var ret = 0;\n    var error = false;\n    for (const chunk of this.chunks) {\n      if (chunk.status === ResumableChunkStatus.ERROR) error = true;\n      ret += chunk.progress(true); // get chunk progress relative to entire file\n    }\n    ret = error ? 1 : (ret > 0.99999 ? 1 : ret);\n    ret = Math.max(this._prevProgress, ret); // We don't want to lose percentages when an upload is paused\n    this._prevProgress = ret;\n    return ret;\n  }\n\n  /**\n   * Check whether at least one of this file's chunks is currently uploading\n   */\n  get isUploading(): boolean {\n    return this.chunks.some((chunk) => chunk.status === ResumableChunkStatus.UPLOADING);\n  }\n\n  /**\n   * Check whether all of this file's chunks completed their upload requests and whether it should be\n   * treated as completed.\n   */\n  get isComplete(): boolean {\n    return !this.chunks.some((chunk) =>\n      chunk.status === ResumableChunkStatus.PENDING || chunk.status === ResumableChunkStatus.UPLOADING);\n  }\n\n  /**\n   * Initiate the upload of a new chunk for this file. This function returns whether a new upload was started or not.\n   */\n  upload(): boolean {\n    if (this.isPaused) {\n      return false;\n    }\n\n    for (const chunk of this.chunks) {\n      if (chunk.status === ResumableChunkStatus.PENDING) {\n        chunk.send();\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Mark a given number of chunks as already uploaded to the server.\n   * @param chunkNumber The index until which all chunks should be marked as completed\n   */\n  markChunksCompleted(chunkNumber: number): void {\n    if (!this.chunks || this.chunks.length <= chunkNumber) {\n      return;\n    }\n    for (let num = 0; num < chunkNumber; num++) {\n      this.chunks[num].markComplete();\n    }\n  }\n}\n","// INTERNAL HELPER METHODS (handy, but ultimately not part of uploading)\nimport {ExtendedFile} from \"./types/types\";\n\nexport default class ResumableHelpers {\n  /**\n   * Stop the propagation and default behavior of the given event `e`.\n   */\n  static stopEvent(e: Event): void {\n    e.stopPropagation();\n    e.preventDefault();\n  }\n\n  /**\n   * Generate a unique identifier for the given file based on its size, filename and relative path.\n   * @param {ExtendedFile} file The file for which the identifier should be generated\n   * @returns {string} The unique identifier for the given file object\n   */\n  static generateUniqueIdentifier(file: ExtendedFile): string {\n    let relativePath = file.webkitRelativePath || file.relativePath || file.name;\n    // The '/' is used to display the relative path of the file. This information should be preserved\n    relativePath = relativePath.replace('/', '-');\n    // Remove special characters\n    return (file.size + '-' + relativePath.replace(/[^0-9a-zA-Z_-]/img, ''));\n  }\n\n  /**\n   * Flatten the given array and all contained subarrays.\n   * Credit: {@link https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore#_flattendeep}\n   */\n  static flattenDeep(array: any[]): any[] {\n    return Array.isArray(array)\n      ? array.reduce((a, b) => a.concat(this.flattenDeep(b)), [])\n      : [array];\n  }\n\n  /**\n   * Filter the given array based on the predicate inside `callback`\n   * and executes `errorCallback` for duplicate elements.\n   */\n  static uniqBy(array: any[], callback: Function, errorCallback: Function): any[] {\n    let seen = new Set();\n    return array.filter((item) => {\n      let k = callback(item);\n      if (seen.has(k)) {\n        errorCallback(item);\n        return false;\n      } else {\n        seen.add(k);\n        return true;\n      }\n    });\n  }\n\n  /**\n   * Format the size given in Bytes in a human readable format.\n   */\n  static formatSize(size: number): string {\n    if (size < 1024) {\n      return size + ' bytes';\n    }\n    if (size < 1024 * 1024) {\n      return (size / 1024.0).toFixed(0) + ' KB';\n    }\n    if (size < 1024 * 1024 * 1024) {\n      return (size / 1024.0 / 1024.0).toFixed(1) + ' MB';\n    }\n    return (size / 1024.0 / 1024.0 / 1024.0).toFixed(1) + ' GB';\n  }\n\n  /**\n   * Get the target url for the specified request type and params\n   */\n  static getTarget(\n    requestType: string,\n    sendTarget: string,\n    testTarget: string,\n    params: object,\n    parameterNamespace: string = ''\n  ) {\n    let target = sendTarget;\n\n    if (requestType === 'test' && testTarget) {\n      target = testTarget === '/' ? sendTarget : testTarget;\n    }\n\n    let separator = target.indexOf('?') < 0 ? '?' : '&';\n    let joinedParams = Object.entries(params).map(([key, value]) => [\n      encodeURIComponent(parameterNamespace + key),\n      encodeURIComponent(value),\n    ].join('=')).join('&');\n\n    if (joinedParams) target = target + separator + joinedParams;\n\n    return target;\n  }\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(603);\n"],"names":["root","factory","exports","module","define","amd","this","Resumable","constructor","options","super","files","uncompletedFileCategories","validators","clearInput","dragOverClass","fileCategories","defaultFileCategory","fileTypes","fileTypeErrorCallback","file","alert","fileName","name","_generateUniqueIdentifier","maxFileSizeErrorCallback","formatSize","maxFileSize","maxFilesErrorCallback","maxFiles","minFileSize","minFileSizeErrorCallback","prioritizeFirstAndLastChunk","fileValidationErrorCallback","simultaneousUploads","setInstanceProperties","opts","checkSupport","support","undefined","File","Blob","FileList","prototype","slice","Error","Object","assign","length","includes","console","warn","push","deduplicatedFileCategories","forEach","fileCategory","Array","isArray","fileTypeCategories","keys","sanitizeFileTypes","map","type","replace","toLowerCase","throwIfUnknownFileCategory","mapDirectoryItemToFile","item","path","isFile","Promise","resolve","reject","relativePath","isDirectory","processDirectory","mapDragItemToFile","entry","webkitGetAsEntry","getAsFile","directory","dirReader","createReader","allEntries","readEntries","entries","concat","all","removeDragOverClassAndCallOnDrop","e","domNode","currentTarget","classList","remove","getAttribute","onDrop","stopEvent","items","dataTransfer","fire","promises","flattenDeep","appendFilesFromFileList","onDragLeave","onDragOverEnter","preventDefault","dt","types","stopPropagation","dropEffect","effectAllowed","add","validateFiles","uniqueFiles","uniqBy","uniqueIdentifier","resumableFiles","validationPromises","some","addedFile","fileType","fileExtension","split","pop","substring","indexOf","size","results","filter","_v","index","fileList","event","allResumableFiles","getFilesOfAllCategories","removeFile","filesWithUniqueIdentifiers","generateUniqueIdentifier","validatedFiles","skippedFiles","f","on","handleChunkSuccess","handleChunkError","handleChunkCancel","args","handleFileProgress","handleFileError","handleFileSuccess","handleFileCancel","handleFileRetry","uploadNextChunk","chunks","status","send","upload","allFiles","assignBrowse","domNodes","HTMLElement","input","HTMLInputElement","document","createElement","setAttribute","style","display","addEventListener","opacity","focus","click","appendChild","removeAttribute","setFileTypes","handleChangeEvent","assignDrop","bind","unAssignDrop","removeEventListener","match","join","isUploading","num","pause","abort","cancel","progress","totalDone","reduce","accumulator","totalSize","getSize","addFile","addFiles","addFileValidator","validator","fileIndex","findIndex","fileFromArray","splice","getFromUniqueIdentifier","find","handleDropEvent","eventTarget","target","value","checkUploadComplete","stillUncompletedFileCategories","every","isComplete","ResumableChunk","fileObj","offset","lastProgressCallback","Date","tested","retries","pendingRetry","isMarkedComplete","loaded","xhr","chunkSize","fileParameterName","chunkNumberParameterName","chunkSizeParameterName","currentChunkSizeParameterName","totalSizeParameterName","typeParameterName","identifierParameterName","fileCategoryParameterName","fileNameParameterName","relativePathParameterName","totalChunksParameterName","throttleProgressCallbacks","query","headers","method","uploadMethod","testMethod","parameterNamespace","testChunks","maxChunkRetries","chunkRetryInterval","permanentErrors","withCredentials","xhrTimeout","chunkFormat","setChunkTypeFromFile","testTarget","fileObjSize","fileObjType","startByte","endByte","Math","min","setCustomHeaders","customHeaders","Function","header","hasOwnProperty","setRequestHeader","formattedQuery","customQuery","extraData","readyState","getTarget","requestType","test","XMLHttpRequest","testHandler","message","open","timeout","now","getTime","doneHandler","retryInterval","setTimeout","bytes","data","FormData","queryKey","append","fr","FileReader","onload","result","readAsDataURL","responseText","relative","factor","markComplete","registeredEventHandlers","callback","executeEventCallback","ResumableFile","_prevProgress","isPaused","webkitRelativePath","_error","bootstrap","abortCount","chunk","retry","firedRetry","progressHandler","retryHandler","successHandler","errorHandler","maxOffset","max","ceil","ret","error","markChunksCompleted","chunkNumber","static","array","a","b","errorCallback","seen","Set","k","has","toFixed","sendTarget","params","separator","joinedParams","key","encodeURIComponent","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","call"],"sourceRoot":""}