{"version":3,"file":"main.js","mappings":"CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,cAAe,GAAIH,GACA,iBAAZC,QACdA,QAAqB,YAAID,IAEzBD,EAAkB,YAAIC,GACvB,CATD,CASGK,MAAM,WACT,O,ubCVA,cACA,SACA,SAaA,MAAaC,UAAkB,UAiC7BC,YAAYC,EAAkC,CAAC,GAC7CC,QAhCM,KAAAC,MAAyB,GACzB,KAAAC,WAA6C,CAAC,EAItD,KAAAC,YAAsB,EACtB,KAAAC,cAAwB,WACxB,KAAAC,UAAsB,GACtB,KAAAC,sBAAmCC,IACjCC,MAAM,GAAGD,EAAKE,UAAYF,EAAKG,kEAAkEd,KAAKS,aAAa,EAErH,KAAAM,0BAAsC,KAEtC,KAAAC,yBAAsCL,IACpCC,MAAMD,EAAKE,UAAYF,EAAKG,KAAO,gDACjC,UAAQG,WAAWjB,KAAKkB,aAAe,IAAI,EAG/C,KAAAC,sBAAmCd,IACjC,IAAIe,EAAWpB,KAAKoB,SACpBR,MAAM,8BAAgCQ,EAAW,SAAwB,IAAbA,EAAiB,GAAK,KAAO,cAAc,EAEzG,KAAAC,YAAsB,EACtB,KAAAC,yBAAsCX,IACpCC,MAAMD,EAAKE,UAAYF,EAAKG,KAAO,kDACjC,UAAQG,WAAWjB,KAAKqB,aAAe,IAAI,EAE/C,KAAAE,6BAAuC,EACvC,KAAAC,4BAAyCb,IAAD,EACxC,KAAAc,oBAA8B,EAI5BzB,KAAK0B,sBAAsBvB,GAC3BH,KAAK2B,KAAOxB,EACZH,KAAK4B,cACP,CAUQA,eAMN,GALA5B,KAAK6B,aACMC,IAATC,WACSD,IAATE,WACaF,IAAbG,YACED,KAAKE,UAAUC,OACdnC,KAAK6B,QACR,MAAM,IAAIO,MAAM,2BAEpB,CAKUV,sBAAsBvB,GAC9BkC,OAAOC,OAAOtC,KAAMG,GACpBH,KAAKuC,mBACP,CAEQA,oBAENvC,KAAKS,UAAYT,KAAKS,UAAU+B,KAAKC,GAASA,EAAKC,QAAQ,SAAU,IAAIC,eAC3E,CAQcC,uBAAuBC,EAAuBC,G,yCAC1D,GAAID,EAAKE,OAAQ,CAEf,MAAMpC,QAAa,IAAIqC,SACrB,CAACC,EAASC,IAAYL,EAA6BlC,KAAKsC,EAASC,KAGnE,OADAvC,EAAKwC,aAAeL,EAAOnC,EAAKG,KACzB,CAACH,E,CACH,OAAIkC,EAAKO,kBAEDpD,KAAKqD,iBAAiBR,EAAkCC,EAAOD,EAAK/B,KAAO,KAC/E+B,aAAgBd,KAClB,CAACc,IAGVS,QAAQC,KAAK,yFACN,GACT,G,CAQcC,kBAAkBX,EAAwBC,G,yCACtD,IAAIW,EAAQZ,EAAKa,mBACjB,GAAID,EAAML,YACR,aAAapD,KAAKqD,iBAAiBI,EAAmCX,EAAOW,EAAM3C,KAAO,KAG5F,IAAIH,EAAOkC,EAAKc,YAChB,OAAIhD,aAAgBoB,MACjBpB,EAAsBwC,aAAeL,EAAOnC,EAAKG,KAC3C,CAACH,KAGV2C,QAAQC,KAAK,yFACN,GACT,G,CAKQF,iBAAiBO,EAAqCd,GAC5D,OAAO,IAAIE,SAAQ,CAACC,EAASC,KAC3B,MAAMW,EAAYD,EAAUE,eAC5B,IAAIC,EAAa,GAEjB,MAAMC,EAAc,KAClBH,EAAUG,aAAmBC,GAA8C,EAAD,gCAExE,GAAIA,EAAQC,OAEV,OADAH,EAAaA,EAAWI,OAAOF,GACxBD,IAITD,EAAaA,EAAWvB,KAAKiB,GACpBzD,KAAK4C,uBAAuBa,EAAOX,KAG5CG,QAAcD,QAAQoB,IAAIL,GAC5B,KAAGb,EAAO,EAGZc,GAAa,GAEjB,CASQK,iCAAiCC,GAGvC,OAFCA,EAAEC,cAA8BC,UAAUC,OAAOzE,KAAKQ,eAEhDR,KAAK0E,OAAOJ,EACrB,CAKcI,OAAOJ,G,yCACnB,UAAQK,UAAUL,GAElB,IAAIM,EAAQ,GAWZ,GARIN,EAAEO,cAAgBP,EAAEO,aAAaD,MACnCA,EAAQ,IAAIN,EAAEO,aAAaD,OAGpBN,EAAEO,cAAgBP,EAAEO,aAAaxE,QACxCuE,EAAS,IAAIN,EAAEO,aAAaxE,SAGzBuE,EAAMV,OACT,OAEFlE,KAAK8E,KAAK,sBAAuBF,GACjC,IAAIG,EAAWH,EAAMpC,KAAKK,GAAS7C,KAAKwD,kBAAkBX,EAAM,MAC5DxC,EAAQ,UAAQ2E,kBAAkBhC,QAAQoB,IAAIW,IAC9C1E,EAAM6D,QAERlE,KAAKiF,wBAAwB5E,EAAOiE,EAExC,G,CAKQY,YAAYZ,GACjBA,EAAEC,cAA8BC,UAAUC,OAAOzE,KAAKQ,cACzD,CAKQ2E,gBAAgBb,GACtBA,EAAEc,iBACF,IAAIC,EAAKf,EAAEO,aACPQ,EAAGC,MAAMC,SAAS,UACpBjB,EAAEkB,kBACFH,EAAGI,WAAa,OAChBJ,EAAGK,cAAgB,OAClBpB,EAAEC,cAA8BC,UAAUmB,IAAI3F,KAAKQ,iBAEpD6E,EAAGI,WAAa,OAChBJ,EAAGK,cAAgB,OAEvB,CAOcE,cAAcvF,G,yCAE1B,IAKIwF,EALc,UAAQC,OAAOzF,GAC9BM,GAASA,EAAKoF,mBACdpF,GAASX,KAAK8E,KAAK,uBAAwBnE,EAAM,eAGf6B,KAAW7B,GAAS,EAAD,gCAEtD,GAAIX,KAAKK,MAAM2F,MAAMC,GAAcA,EAAUF,mBAAqBpF,EAAKoF,mBAErE,OADA/F,KAAK8E,KAAK,uBAAwBnE,EAAM,cACjC,EAGT,IAAIuF,EAAmBvF,EAAK8B,KAAKE,cAC7BwD,EAAgBxF,EAAKG,KAAKsF,MAAM,KAAKC,MAAM1D,cAE/C,OAAI3C,KAAKS,UAAUyD,OAAS,IACJlE,KAAKS,UAAUuF,MAAMvD,GAElC0D,IAAkB1D,GAEvBA,EAAK8C,SAAS,OACZ9C,EAAK8C,SAAS,MACdW,EAASI,UAAU,EAAG7D,EAAK8D,QAAQ,QAAU9D,EAAK6D,UAAU,EAAG7D,EAAK8D,QAAQ,OAC5EL,IAAazD,MAIjBzC,KAAK8E,KAAK,uBAAwBnE,EAAM,YACxCX,KAAKU,sBAAsBC,IACpB,QAKcmB,IAArB9B,KAAKqB,aAA6BV,EAAK6F,KAAOxG,KAAKqB,aACrDrB,KAAK8E,KAAK,uBAAwBnE,EAAM,eACxCX,KAAKsB,yBAAyBX,IACvB,QAEgBmB,IAArB9B,KAAKkB,aAA6BP,EAAK6F,KAAOxG,KAAKkB,aACrDlB,KAAK8E,KAAK,uBAAwBnE,EAAM,eACxCX,KAAKgB,yBAAyBL,IACvB,KAILwF,KAAiBnG,KAAKM,oBAAqBN,KAAKM,WAAW6F,GAAexF,MAC5EX,KAAK8E,KAAK,uBAAwBnE,EAAM,cACxCX,KAAKwB,4BAA4Bb,GAC1B,GAIX,MAEA,MAAM8F,QAAgBzD,QAAQoB,IAAIyB,GAGlC,OAAOxF,EAAMqG,QAAO,CAACC,EAAIC,IAAUH,EAAQG,IAC7C,G,CAQc3B,wBAAwB4B,EAAkBC,G,yCAEtD,QAAsBhF,IAAlB9B,KAAKoB,UAA0BpB,KAAKoB,SAAWyF,EAAS3C,OAASlE,KAAKK,MAAM6D,OAAQ,CAEtF,GAAsB,IAAlBlE,KAAKoB,UAAwC,IAAtBpB,KAAKK,MAAM6D,QAAoC,IAApB2C,EAAS3C,OAK7D,OAFAlE,KAAK8E,KAAK,4BAAwBhD,EAAW,YAC7C9B,KAAKmB,sBAAsB0F,IACpB,EAJP7G,KAAK+G,WAAW/G,KAAKK,MAAM,G,CAU/B,MAAM2G,QAAmChE,QAAQoB,IAAIyC,EAASrE,KAAW7B,GAA8C,EAAD,gCAEpH,OADAA,EAAKoF,uBAAyB/F,KAAKiH,yBAAyBtG,EAAMmG,GAC3DnG,CACT,OAGMuG,QAAuBlH,KAAK4F,cAAcoB,GAEhD,IAAIG,EAAeH,EAA2BN,QAAQ/F,IAAUuG,EAAe3B,SAAS5E,KAExF,IAAK,MAAMA,KAAQuG,EAAgB,CACjC,IAAIE,EAAI,IAAI,UAAczG,EAAMA,EAAKoF,iBAAkB/F,KAAK2B,MAC5DyF,EAAEC,GAAG,gBAAgB,IAAMrH,KAAKsH,uBAChCF,EAAEC,GAAG,cAAc,IAAMrH,KAAKuH,qBAC9BH,EAAEC,GAAG,eAAe,IAAMrH,KAAKwH,sBAC/BJ,EAAEC,GAAG,gBAAgB,IAAII,IAASzH,KAAK0H,mBAAmBD,KAC1DL,EAAEC,GAAG,aAAa,IAAII,IAASzH,KAAK2H,gBAAgBF,KACpDL,EAAEC,GAAG,eAAe,IAAII,IAASzH,KAAK4H,kBAAkBH,KACxDL,EAAEC,GAAG,cAAc,IAAII,IAASzH,KAAK6H,iBAAiBJ,KACtDL,EAAEC,GAAG,aAAa,IAAMrH,KAAK8H,oBAC7B9H,KAAKK,MAAM0H,KAAKX,GAChBpH,KAAK8E,KAAK,YAAasC,EAAGN,E,EAIvBI,EAAehD,QAAWiD,EAAajD,SAI5ClE,KAAK8E,KAAK,aAAcoC,EAAgBC,EAC1C,G,CAQQF,yBAAyBtG,EAAYmG,GAC3C,MAAiD,mBAAnC9G,KAAKe,0BACjBf,KAAKe,0BAA0BJ,EAAMmG,GAAS,UAAQG,yBAAyBtG,EACnF,CAKQqH,kBAIN,GAAIhI,KAAKuB,4BACP,IAAK,MAAMZ,KAAQX,KAAKK,MAAO,CAC7B,GAAIM,EAAKsH,OAAO/D,QAAoC,iBAA1BvD,EAAKsH,OAAO,GAAGC,OAEvC,YADAvH,EAAKsH,OAAO,GAAGE,OAGjB,GAAIxH,EAAKsH,OAAO/D,OAAS,GAAoD,iBAA/CvD,EAAKsH,OAAOtH,EAAKsH,OAAO/D,OAAS,GAAGgE,OAEhE,YADAvH,EAAKsH,OAAOtH,EAAKsH,OAAO/D,OAAS,GAAGiE,M,CAO1C,IAAK,MAAMxH,KAAQX,KAAKK,MACtB,GAAIM,EAAKyH,SAAU,MAEvB,CAUAC,aAAaC,EAAuClF,GAAuB,GACrEkF,aAAoBC,cAAaD,EAAW,CAACA,IACjD,IAAK,MAAME,KAAWF,EAAU,CAC9B,IAAIG,EACAD,aAAmBE,kBAAqC,SAAjBF,EAAQ/F,KACjDgG,EAAQD,GAERC,EAAQE,SAASC,cAAc,SAC/BH,EAAMI,aAAa,OAAQ,QAC3BJ,EAAMK,MAAMC,QAAU,OACtBP,EAAQQ,iBAAiB,SAAS,KAChCP,EAAMK,MAAMG,QAAU,EACtBR,EAAMK,MAAMC,QAAU,QACtBN,EAAMS,QACNT,EAAMU,QACNV,EAAMK,MAAMC,QAAU,MAAM,IAC3B,GACHP,EAAQY,YAAYX,IAEA,IAAlBzI,KAAKoB,SACPqH,EAAMI,aAAa,WAAY,YAE/BJ,EAAMY,gBAAgB,YAEpBjG,EACFqF,EAAMI,aAAa,kBAAmB,mBAEtCJ,EAAMY,gBAAgB,mBAExBrJ,KAAKsJ,aAAatJ,KAAKS,UAAWgI,GAElCA,EAAMO,iBAAiB,SAAUhJ,KAAKuJ,kBAAkBC,KAAKxJ,OAAO,E,CAExE,CAKAyJ,WAAWnB,GACLA,aAAoBC,cAAaD,EAAW,CAACA,IAEjD,IAAK,MAAME,KAAWF,EACpBE,EAAQQ,iBAAiB,WAAYhJ,KAAKmF,gBAAgBqE,KAAKxJ,OAAO,GACtEwI,EAAQQ,iBAAiB,YAAahJ,KAAKmF,gBAAgBqE,KAAKxJ,OAAO,GACvEwI,EAAQQ,iBAAiB,YAAahJ,KAAKkF,YAAYsE,KAAKxJ,OAAO,GACnEwI,EAAQQ,iBAAiB,OAAQhJ,KAAKqE,iCAAiCmF,KAAKxJ,OAAO,EAEvF,CAKA0J,aAAapB,GACPA,aAAoBC,cAAaD,EAAW,CAACA,IAEjD,IAAK,MAAME,KAAWF,EACpBE,EAAQmB,oBAAoB,WAAY3J,KAAKmF,gBAAgBqE,KAAKxJ,OAClEwI,EAAQmB,oBAAoB,YAAa3J,KAAKmF,gBAAgBqE,KAAKxJ,OACnEwI,EAAQmB,oBAAoB,YAAa3J,KAAKkF,YAAYsE,KAAKxJ,OAC/DwI,EAAQmB,oBAAoB,OAAQ3J,KAAKqE,iCAAiCmF,KAAKxJ,MAEnF,CAMAsJ,aAAa7I,EAAqB+H,EAA4B,MAC5D,GAAIA,GAA4B,SAAjBA,EAAQ/F,KACrB,MAAM,IAAIL,MAAM,iCAIlBpC,KAAKS,UAAYA,EACjBT,KAAKuC,oBAEDiG,IACE/H,EAAUyD,QAAU,EAEtBsE,EAAQK,aAAa,SAAU7I,KAAKS,UAAU+B,KAAKC,IAC7CA,EAAKmH,MAAM,iBACbnH,EAAO,IAAMA,GAERA,KACNoH,KAAK,MAGRrB,EAAQa,gBAAgB,UAG9B,CAKIS,kBACF,OAAO9J,KAAKK,MAAM2F,MAAMrF,GAASA,EAAKmJ,aACxC,CAKA1B,SAEE,IAAIpI,KAAK8J,YAAT,CAEA9J,KAAK8E,KAAK,eACV,IAAK,IAAIiF,EAAM,EAAGA,GAAO/J,KAAKyB,oBAAqBsI,IACjD/J,KAAKgI,iBAJqB,CAM9B,CAKAgC,QAEE,IAAK,MAAMrJ,KAAQX,KAAKK,MACtBM,EAAKsJ,QAEPjK,KAAK8E,KAAK,QACZ,CAKAoF,SACElK,KAAK8E,KAAK,gBACV,IAAK,IAAIqF,EAAInK,KAAKK,MAAM6D,OAAS,EAAGiG,GAAK,EAAGA,IAC1CnK,KAAKK,MAAM8J,GAAGD,SAEhBlK,KAAK8E,KAAK,SACZ,CAKAsF,WACE,IAAIC,EAAYrK,KAAKK,MAAMiK,QAAO,CAACC,EAAa5J,IAAS4J,EAAc5J,EAAK6F,KAAO7F,EAAKyJ,YAAY,GAChGI,EAAYxK,KAAKyK,UACrB,OAAOD,EAAY,EAAIH,EAAYG,EAAY,CACjD,CAKAE,QAAQ/J,EAAYmG,GAClB9G,KAAKiF,wBAAwB,CAACtE,GAAOmG,EACvC,CAKA6D,SAAStK,EAAeyG,GACtB9G,KAAKiF,wBAAwB5E,EAAOyG,EACtC,CAQA8D,iBAAiB1E,EAAkB2E,GAC7B3E,KAAYlG,KAAKM,YACnBgD,QAAQC,KAAK,wCAAwC2C,KAEvDlG,KAAKM,WAAW4F,GAAY2E,CAC9B,CAKA9D,WAAWpG,GACT,IAAK,IAAIwJ,EAAInK,KAAKK,MAAM6D,OAAS,EAAGiG,GAAK,EAAGA,IAC1C,GAAInK,KAAKK,MAAM8J,KAAOxJ,EAAM,CAC1BX,KAAKK,MAAMyK,OAAOX,EAAG,GACrB,K,CAGN,CAKAY,wBAAwBhF,GACtB,OAAO/F,KAAKK,MAAM2K,MAAMrK,GAASA,EAAKoF,mBAAqBA,GAC7D,CAKA0E,UACE,OAAOzK,KAAKK,MAAMiK,QAAO,CAACC,EAAa5J,IAAS4J,EAAc5J,EAAK6F,MAAM,EAC3E,CAKAyE,gBAAgB3G,GACdtE,KAAK0E,OAAOJ,EACd,CAKAiF,kBAAkBjF,GAChB,MAAM4G,EAAc5G,EAAE6G,OACtBnL,KAAK8E,KAAK,sBAAuBoG,EAAY7K,OAC7CL,KAAKiF,wBAAwB,IAAIiG,EAAY7K,OAAeiE,GACxDtE,KAAKO,aACP2K,EAAYE,MAAQ,GAExB,CAKAC,sBACwBrL,KAAKK,MAAMiL,OAAO3K,GAASA,EAAK4K,cAGpDvL,KAAK8E,KAAK,WAEd,CAUQwC,qBACNtH,KAAKgI,iBACP,CAKQT,mBACNvH,KAAKgI,iBACP,CAKQR,oBACNxH,KAAKgI,iBACP,CAKQL,gBAAgBF,GACtBzH,KAAK8E,KAAK,QAAS2C,EAAK,GAAIA,EAAK,GACnC,CAKQG,kBAAkBH,GACxBzH,KAAK8E,KAAK,iBAAkB2C,GAC5BzH,KAAKqL,qBACP,CAKQ3D,mBAAmBD,GACzBzH,KAAK8E,KAAK,kBAAmB2C,GAC7BzH,KAAK8E,KAAK,WACZ,CAKQ+C,iBAAiBJ,GACvBzH,KAAK+G,WAAWU,EAAK,GACvB,CAKQK,kBACN9H,KAAKoI,QACP,EA3pBF,a,uECfA,cACA,SAOA,MAAqBoD,UAAuB,UA8C1CtL,YAAYuL,EAAwBC,EAAgBvL,GAClDC,QA1CM,KAAAuL,qBAA6B,IAAIC,KACjC,KAAAC,QAAkB,EAClB,KAAAC,QAAkB,EAClB,KAAAC,cAAwB,EACxB,KAAAC,kBAA4B,EAC5B,KAAAC,OAAiB,EAGjB,KAAAC,IAAsB,KAGtB,KAAAC,UAAoB,QACpB,KAAAC,kBAA4B,OACpC,KAAAC,yBAAmC,uBACnC,KAAAC,uBAAiC,qBACjC,KAAAC,8BAAwC,4BACxC,KAAAC,uBAAiC,qBACjC,KAAAC,kBAA4B,gBAC5B,KAAAC,wBAAkC,sBAClC,KAAAC,sBAAgC,oBAChC,KAAAC,0BAAoC,wBACpC,KAAAC,yBAAmC,uBACnC,KAAAC,0BAAoC,GACpC,KAAAC,MAAgB,CAAC,EACjB,KAAAC,QAAkB,CAAC,EACnB,KAAAC,OAAiB,YACjB,KAAAC,aAAuB,OACvB,KAAAC,WAAqB,MACrB,KAAAC,mBAA6B,GAC7B,KAAAC,YAAsB,EACtB,KAAAC,gBAA0B,IAC1B,KAAAC,wBAA8BzL,EAC9B,KAAA0L,gBAA4B,CAAC,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,KAChE,KAAAC,iBAA2B,EAC3B,KAAAC,WAAqB,EACrB,KAAAC,YAAsB,OACtB,KAAAC,sBAAgC,EAChC,KAAAzC,OAAiB,IACjB,KAAA0C,WAAqB,GAKnB7N,KAAK0B,sBAAsBvB,GAC3BH,KAAKyL,QAAUA,EACfzL,KAAK8N,YAAcrC,EAAQjF,KAC3BxG,KAAK+N,YAActC,EAAQ9K,KAAK8B,KAChCzC,KAAK0L,OAASA,EAGd1L,KAAKgO,UAAYhO,KAAK0L,OAAS1L,KAAKmM,UACpCnM,KAAKiO,QAAUC,KAAKC,IAAInO,KAAK8N,aAAc9N,KAAK0L,OAAS,GAAK1L,KAAKmM,WACnEnM,KAAKkM,IAAM,IACb,CAKUxK,sBAAsBvB,GAC9BkC,OAAOC,OAAOtC,KAAMG,EACtB,CAKAiO,mBACE,IAAKpO,KAAKkM,IACR,OAEF,IAAImC,EAAgBrO,KAAKgN,QACrBqB,aAAyBC,WAC3BD,EAAgBA,EAAcrO,KAAKyL,QAASzL,OAE9C,IAAK,MAAMuO,KAAUF,EACdA,EAAcG,eAAeD,IAClCvO,KAAKkM,IAAIuC,iBAAiBF,EAAQF,EAAcE,GAEpD,CAKIG,qBACF,IAAIC,EAAc3O,KAAK+M,MACG,mBAAf4B,IAA2BA,EAAcA,EAAY3O,KAAKyL,QAASzL,OAG9E,MAAM4O,EAAY,CAEhB,CAAC5O,KAAKqM,0BAA2BrM,KAAK0L,OAAS,EAC/C,CAAC1L,KAAKsM,wBAAyBtM,KAAKmM,UACpC,CAACnM,KAAKuM,+BAAgCvM,KAAKiO,QAAUjO,KAAKgO,UAC1D,CAAChO,KAAKwM,wBAAyBxM,KAAK8N,YACpC,CAAC9N,KAAKyM,mBAAoBzM,KAAK+N,YAC/B,CAAC/N,KAAK0M,yBAA0B1M,KAAKyL,QAAQ1F,iBAC7C,CAAC/F,KAAK2M,uBAAwB3M,KAAKyL,QAAQ5K,SAC3C,CAACb,KAAK4M,2BAA4B5M,KAAKyL,QAAQtI,aAC/C,CAACnD,KAAK6M,0BAA2B7M,KAAKyL,QAAQxD,OAAO/D,QAEvD,OAAO,OAAP,wBAAW0K,GAAcD,EAC3B,CAKIzG,aACF,OAAIlI,KAAK+L,aAGA,iBACE/L,KAAKgM,iBACP,eACGhM,KAAKkM,IAENlM,KAAKkM,IAAI2C,WAAa,EAExB,iBACsB,MAApB7O,KAAKkM,IAAIhE,QAAsC,MAApBlI,KAAKkM,IAAIhE,OAEtC,eACElI,KAAKwN,gBAAgBjI,SAASvF,KAAKkM,IAAIhE,SAAWlI,KAAK8L,SAAW9L,KAAKsN,gBAEzE,cAIPtN,KAAKiK,QACE,gBAdA,cAgBX,CAMA6E,UAAUC,GACR,OAAO,UAAQD,UAAUC,EAAa/O,KAAKmL,OAAQnL,KAAK6N,WAAY7N,KAAK0O,eAAgB1O,KAAKoN,mBAChG,CAKA4B,OAEEhP,KAAKkM,IAAM,IAAI+C,eAEf,IAAIC,EAAc,KAChBlP,KAAK6L,QAAS,EAEC,iBADF7L,KAAKkI,OAEhBlI,KAAK8E,KAAK,eAAgB9E,KAAKmP,WAE/BnP,KAAKmI,M,EAGTnI,KAAKkM,IAAIlD,iBAAiB,OAAQkG,GAAa,GAC/ClP,KAAKkM,IAAIlD,iBAAiB,QAASkG,GAAa,GAChDlP,KAAKkM,IAAIlD,iBAAiB,UAAWkG,GAAa,GAGlDlP,KAAKkM,IAAIkD,KAAKpP,KAAKmN,WAAYnN,KAAK8O,UAAU,SAC9C9O,KAAKkM,IAAImD,QAAUrP,KAAK0N,WACxB1N,KAAKkM,IAAIuB,gBAAkBzN,KAAKyN,gBAEhCzN,KAAKoO,mBAELpO,KAAKkM,IAAI/D,KAAK,KAChB,CAKA8B,QACMjK,KAAKkM,KAAKlM,KAAKkM,IAAIjC,QACvBjK,KAAKkM,IAAM,IACb,CAKA/D,OACE,GAAInI,KAAKqN,aAAerN,KAAK6L,OAE3B,YADA7L,KAAKgP,OAKPhP,KAAKkM,IAAM,IAAI+C,eAGfjP,KAAKkM,IAAI9D,OAAOY,iBAAiB,YAAa1E,IACxCsH,KAAK0D,MAAQtP,KAAK2L,qBAAqB4D,UAA6C,IAAjCvP,KAAK8M,4BAC1D9M,KAAK8E,KAAK,iBACV9E,KAAK2L,qBAAuB,IAAIC,MAElC5L,KAAKiM,OAAS3H,EAAE2H,QAAU,CAAC,IAC1B,GACHjM,KAAKiM,OAAS,EACdjM,KAAK+L,cAAe,EACpB/L,KAAK8E,KAAK,iBAKV,IAAI0K,EAAc,KAChB,IAAItH,EAASlI,KAAKkI,OAClB,OAAQA,GACN,IAAK,eACL,IAAK,aACHlI,KAAK8E,KAAKoD,EAAQlI,KAAKmP,WACvB,MACF,QACEnP,KAAK8E,KAAK,aAAc9E,KAAKmP,WAC7BnP,KAAKiK,QACLjK,KAAK8L,UACL,IAAI2D,EAAgBzP,KAAKuN,wBACHzL,IAAlB2N,GACFzP,KAAK+L,cAAe,EACpB2D,WAAW1P,KAAKmI,KAAMsH,IAEtBzP,KAAKmI,O,EAKbnI,KAAKkM,IAAIlD,iBAAiB,OAAQwG,GAAa,GAC/CxP,KAAKkM,IAAIlD,iBAAiB,QAASwG,GAAa,GAChDxP,KAAKkM,IAAIlD,iBAAiB,UAAWwG,GAAa,GAGlD,IAAIG,EAAQ3P,KAAKyL,QAAQ9K,KAAKwB,MAAMnC,KAAKgO,UAAWhO,KAAKiO,QACvDjO,KAAK4N,qBAAuB5N,KAAKyL,QAAQ9K,KAAK8B,KAAO,IACnDmN,EAAO,KACPxC,EAAqBpN,KAAKoN,mBAE9B,GAAoB,UAAhBpN,KAAKiN,OACP2C,EAAOD,MACF,CACLC,EAAO,IAAIC,SACX,IAAK,MAAMC,KAAY9P,KAAK0O,eAC1BkB,EAAKG,OAAO3C,EAAqB0C,EAAU9P,KAAK0O,eAAeoB,IAEjE,OAAQ9P,KAAK2N,aACX,IAAK,OACHiC,EAAKG,OAAO3C,EAAqBpN,KAAKoM,kBAAmBuD,EAAO3P,KAAKyL,QAAQ5K,UAC7E,MACF,IAAK,SACH,IAAImP,EAAK,IAAIC,WACbD,EAAGE,OAAS,KACVN,EAAKG,OAAO3C,EAAqBpN,KAAKoM,kBAAmB4D,EAAGG,QAC5DnQ,KAAKkM,IAAI/D,KAAKyH,EAAK,EAErBI,EAAGI,cAAcT,G,CAKvB,IAAIxE,EAASnL,KAAK8O,UAAU,UAE5B9O,KAAKkM,IAAIkD,KAAKpP,KAAKkN,aAAc/B,GACb,UAAhBnL,KAAKiN,QACPjN,KAAKkM,IAAIuC,iBAAiB,eAAgB,4BAE5CzO,KAAKkM,IAAImD,QAAUrP,KAAK0N,WACxB1N,KAAKkM,IAAIuB,gBAAkBzN,KAAKyN,gBAEhCzN,KAAKoO,mBAEoB,SAArBpO,KAAK2N,aACP3N,KAAKkM,IAAI/D,KAAKyH,EAElB,CAKAT,UACE,OAAOnP,KAAKkM,IAAMlM,KAAKkM,IAAImE,aAAe,EAC5C,CAMAjG,SAASkG,GAAoB,GAC3B,IAAIC,EAASD,GAAYtQ,KAAKiO,QAAUjO,KAAKgO,WAAahO,KAAK8N,YAAc,EAC7E,GAAI9N,KAAK+L,aAAc,OAAO,EAE9B,OADM/L,KAAKkM,KAAQlM,KAAKkM,IAAIhE,QAAYlI,KAAKgM,mBAAkBuE,GAAU,KACjEvQ,KAAKkI,QACX,IAAK,eACL,IAAK,aACH,OAAOqI,EACT,IAAK,eACH,OAAO,EACT,QACE,OAAOvQ,KAAKiM,QAAUjM,KAAKiO,QAAUjO,KAAKgO,WAAauC,EAE7D,CAKAC,eACExQ,KAAKgM,kBAAmB,CAC1B,EArTF,W,qECJA,gBAME9L,cACEF,KAAKyQ,wBAA0B,CAAC,CAClC,CAKApJ,GAAGP,EAAe4J,GAChB5J,EAAQA,EAAMnE,cACT3C,KAAKyQ,wBAAwBjC,eAAe1H,KAC/C9G,KAAKyQ,wBAAwB3J,GAAS,IAExC9G,KAAKyQ,wBAAwB3J,GAAOiB,KAAK2I,EAC3C,CAKA5L,KAAKgC,KAAkBW,GACrBX,EAAQA,EAAMnE,cAEd3C,KAAK2Q,qBAAqB7J,KAAUW,GACpCzH,KAAK2Q,qBAAqB,IAAK7J,KAAUW,EAC3C,CAMQkJ,qBAAqB7J,KAAkBW,GACxCzH,KAAKyQ,wBAAwBjC,eAAe1H,IACjD9G,KAAKyQ,wBAAwB3J,GAAO8J,SAASF,GAAaA,KAAYjJ,IACxE,E,uEC1CF,eAEA,SAMA,MAAqBoJ,UAAsB,UAczC3Q,YAAYS,EAAYoF,EAA0B5F,GAChDC,QAbM,KAAA0Q,cAAwB,EACxB,KAAAC,UAAoB,EAQ5B,KAAA9I,OAA2B,GACnB,KAAAkE,UAAoB,QAI1BnM,KAAK2B,KAAOxB,EACZH,KAAK0B,sBAAsBvB,GAC3BH,KAAKW,KAAOA,EACZX,KAAKa,SAAWF,EAAKG,KACrBd,KAAKwG,KAAO7F,EAAK6F,KACjBxG,KAAKmD,aAAwCxC,EAAKqQ,oBAAsBhR,KAAKa,SAC7Eb,KAAK+F,iBAAmBA,EACxB/F,KAAKiR,YAA8BnP,IAArBiE,EAGd/F,KAAK8E,KAAK,gBAAiB9E,MAC3BA,KAAKkR,WACP,CAKUxP,sBAAsBvB,GAC9BkC,OAAOC,OAAOtC,KAAMG,EACtB,CAKA8J,QACE,IAAIkH,EAAa,EACjB,IAAK,MAAMC,KAASpR,KAAKiI,OACF,mBAAjBmJ,EAAMlJ,SACRkJ,EAAMnH,QACNkH,KAGAA,EAAa,GAAGnR,KAAK8E,KAAK,eAAgB9E,KAChD,CAKAkK,SACE,IAAK,MAAMkH,KAASpR,KAAKiI,OACF,mBAAjBmJ,EAAMlJ,SACRkJ,EAAMnH,QACNjK,KAAK8E,KAAK,cAAesM,IAI7BpR,KAAKiI,OAAS,GACdjI,KAAK8E,KAAK,aAAc9E,MACxBA,KAAK8E,KAAK,eAAgB9E,KAC5B,CAKAqR,QACErR,KAAKkR,YACL,IAAII,GAAa,EACjBtR,KAAKqH,GAAG,oBAAoB,KACrBiK,GAAYtR,KAAK8E,KAAK,aAC3BwM,GAAa,CAAI,GAErB,CAKAJ,YACE,MAAMK,EAAmBpC,GAAYnP,KAAK8E,KAAK,eAAgB9E,KAAMmP,GAC/DqC,EAAe,IAAOxR,KAAK8E,KAAK,YAAa9E,MAC7CyR,EAAkBtC,IAClBnP,KAAKiR,SACTjR,KAAK8E,KAAK,gBACV9E,KAAK8E,KAAK,eAAgB9E,KAAMmP,GAC5BnP,KAAKuL,YACPvL,KAAK8E,KAAK,cAAe9E,KAAMmP,G,EAG7BuC,EAAgBvC,IACpBnP,KAAK8E,KAAK,aAAcqK,GACxBnP,KAAKiK,QACLjK,KAAKiR,QAAS,EACdjR,KAAKiI,OAAS,GACdjI,KAAK8E,KAAK,YAAa9E,KAAMmP,EAAQ,EAGvCnP,KAAKiK,QACLjK,KAAKiR,QAAS,EAEdjR,KAAKiI,OAAS,GACdjI,KAAK8Q,cAAgB,EACrB,MAAMa,EAAYzD,KAAK0D,IAAI1D,KAAK2D,KAAK7R,KAAKW,KAAK6F,KAAOxG,KAAKmM,WAAY,GACvE,IAAK,IAAIT,EAAS,EAAGA,EAASiG,EAAWjG,IAAU,CACjD,MAAM0F,EAAQ,IAAI,UAAepR,KAAM0L,EAAQ1L,KAAK2B,MACpDyP,EAAM/J,GAAG,gBAAiBkK,GAC1BH,EAAM/J,GAAG,aAAcqK,GACvBN,EAAM/J,GAAG,eAAgBoK,GACzBL,EAAM/J,GAAG,aAAcmK,GACvBxR,KAAKiI,OAAOF,KAAKqJ,GACjBpR,KAAK8E,KAAK,mBAAoB9E,KAAM0L,EAASiG,E,CAE/C3R,KAAK8E,KAAK,mBAAoB9E,KAChC,CAKAoK,WACE,GAAIpK,KAAKiR,OAAQ,OAAO,EAExB,IAAIa,EAAM,EACNC,GAAQ,EACZ,IAAK,MAAMX,KAASpR,KAAKiI,OACF,eAAjBmJ,EAAMlJ,SAAuC6J,GAAQ,GACzDD,GAAOV,EAAMhH,UAAS,GAKxB,OAHA0H,EAAMC,GAAaD,EAAM,OAAX,EAAyBA,EACvCA,EAAM5D,KAAK0D,IAAI5R,KAAK8Q,cAAegB,GACnC9R,KAAK8Q,cAAgBgB,EACdA,CACT,CAKIhI,kBACF,OAAO9J,KAAKiI,OAAOjC,MAAMoL,GAA2B,mBAAjBA,EAAMlJ,QAC3C,CAMIqD,iBACF,OAAQvL,KAAKiI,OAAOjC,MAAMoL,GACP,iBAAjBA,EAAMlJ,QAA4D,mBAAjBkJ,EAAMlJ,QAC3D,CAKAE,SACE,GAAIpI,KAAK+Q,SACP,OAAO,EAGT,IAAK,MAAMK,KAASpR,KAAKiI,OACvB,GAAqB,iBAAjBmJ,EAAMlJ,OAER,OADAkJ,EAAMjJ,QACC,EAGX,OAAO,CACT,CAMA6J,oBAAoBC,GAClB,GAAKjS,KAAKiI,UAAUjI,KAAKiI,OAAO/D,QAAU+N,GAG1C,IAAK,IAAIlI,EAAM,EAAGA,EAAMkI,EAAalI,IACnC/J,KAAKiI,OAAO8B,GAAKyG,cAErB,EArLF,W,oECLA,gBAIE0B,iBAAiB5N,GACfA,EAAEkB,kBACFlB,EAAEc,gBACJ,CAOA8M,gCAAgCvR,GAC9B,IAAIwC,EAAexC,EAAKqQ,oBAAsBrQ,EAAKwC,cAAgBxC,EAAKG,KAIxE,OAFAqC,EAAeA,EAAaT,QAAQ,IAAK,KAEjC/B,EAAK6F,KAAO,IAAMrD,EAAaT,QAAQ,oBAAqB,GACtE,CAMAwP,mBAAmBC,GACjB,OAAOC,MAAMC,QAAQF,GACjBA,EAAM7H,QAAO,CAACgI,EAAGC,IAAMD,EAAEnO,OAAOnE,KAAKgF,YAAYuN,KAAK,IACtD,CAACJ,EACP,CAMAD,cAAcC,EAAczB,EAAoB8B,GAC9C,IAAIC,EAAO,IAAIC,IACf,OAAOP,EAAMzL,QAAQ7D,IACnB,IAAI8P,EAAIjC,EAAS7N,GACjB,OAAI4P,EAAKG,IAAID,IACXH,EAAc3P,IACP,IAEP4P,EAAK9M,IAAIgN,IACF,E,GAGb,CAKAT,kBAAkB1L,GAChB,OAAIA,EAAO,KACFA,EAAO,SAEZA,EAAO,SACDA,EAAO,MAAQqM,QAAQ,GAAK,MAElCrM,EAAO,YACDA,EAAO,KAAS,MAAQqM,QAAQ,GAAK,OAEvCrM,EAAO,KAAS,KAAS,MAAQqM,QAAQ,GAAK,KACxD,CAKAX,iBACEnD,EACA+D,EACAjF,EACAkF,EACA3F,EAA6B,IAE7B,IAAIjC,EAAS2H,EAEO,SAAhB/D,GAA0BlB,IAC5B1C,EAAwB,MAAf0C,EAAqBiF,EAAajF,GAG7C,IAAImF,EAAY7H,EAAO5E,QAAQ,KAAO,EAAI,IAAM,IAC5C0M,EAAe5Q,OAAO4B,QAAQ8O,GAAQvQ,KAAI,EAAE0Q,EAAK9H,KAAW,CAC9D+H,mBAAmB/F,EAAqB8F,GACxCC,mBAAmB/H,IACnBvB,KAAK,OAAMA,KAAK,KAIlB,OAFIoJ,IAAc9H,EAASA,EAAS6H,EAAYC,GAEzC9H,CACT,E,GC7FEiI,EAA2B,CAAC,E,OAGhC,SAASC,EAAoBC,GAE5B,IAAIC,EAAeH,EAAyBE,GAC5C,QAAqBxR,IAAjByR,EACH,OAAOA,EAAa3T,QAGrB,IAAIC,EAASuT,EAAyBE,GAAY,CAGjD1T,QAAS,CAAC,GAOX,OAHA4T,EAAoBF,GAAUG,KAAK5T,EAAOD,QAASC,EAAQA,EAAOD,QAASyT,GAGpExT,EAAOD,OACf,CCnB0ByT,CAAoB,I","sources":["webpack://resumablejs/webpack/universalModuleDefinition","webpack://resumablejs/./src/resumable.ts","webpack://resumablejs/./src/resumableChunk.ts","webpack://resumablejs/./src/resumableEventHandler.ts","webpack://resumablejs/./src/resumableFile.ts","webpack://resumablejs/./src/resumableHelpers.ts","webpack://resumablejs/webpack/bootstrap","webpack://resumablejs/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"resumablejs\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"resumablejs\"] = factory();\n\telse\n\t\troot[\"resumablejs\"] = factory();\n})(this, function() {\nreturn ","import Helpers from './resumableHelpers';\nimport ResumableFile from './resumableFile';\nimport ResumableEventHandler from './resumableEventHandler';\nimport {ExtendedFile, ResumableChunkStatus, ResumableConfiguration} from './types/types';\n\n/*\n* MIT Licensed\n* http://www.twentythree.com/\n* http://github.com/23/resumable.js\n* Steffen Tiedemann Christensen, steffen@twentythree.com\n*/\n\n/**\n * An instance of a resumable upload handler that contains one or multiple files which should be uploaded in chunks.\n */\nexport class Resumable extends ResumableEventHandler {\n  private opts: ResumableConfiguration;\n  private files: ResumableFile[] = [];\n  private validators: {[fileType: string]: Function} = {};\n  private support: boolean;\n\n  // Configuration Options\n  clearInput: boolean = true;\n  dragOverClass: string = 'dragover';\n  fileTypes: string[] = [];\n  fileTypeErrorCallback: Function = (file) => {\n    alert(`${file.fileName || file.name} has an unsupported file type, please upload files of type ${this.fileTypes}.`);\n  };\n  _generateUniqueIdentifier: Function = null;\n  maxFileSize?: number;\n  maxFileSizeErrorCallback: Function = (file) => {\n    alert(file.fileName || file.name + ' is too large, please upload files less than ' +\n      Helpers.formatSize(this.maxFileSize) + '.');\n  };\n  maxFiles?: number;\n  maxFilesErrorCallback: Function = (files) => {\n    var maxFiles = this.maxFiles;\n    alert('Please upload no more than ' + maxFiles + ' file' + (maxFiles === 1 ? '' : 's') + ' at a time.');\n  };\n  minFileSize: number = 1;\n  minFileSizeErrorCallback: Function = (file) => {\n    alert(file.fileName || file.name + ' is too small, please upload files larger than ' +\n      Helpers.formatSize(this.minFileSize) + '.');\n  };\n  prioritizeFirstAndLastChunk: boolean = false;\n  fileValidationErrorCallback: Function = (file) => {};\n  simultaneousUploads: number = 3;\n\n  constructor(options: ResumableConfiguration = {}) {\n    super();\n    this.setInstanceProperties(options);\n    this.opts = options;\n    this.checkSupport();\n  }\n\n  /**\n   * Check whether the current browser supports the essential functions for the package to work.\n   * The method checks if these features are supported:\n   * - File object type\n   * - Blob object type\n   * - FileList object type\n   * - slicing files\n   */\n  private checkSupport(): void {\n    this.support =\n      File !== undefined &&\n      Blob !== undefined &&\n      FileList !== undefined &&\n      !!Blob.prototype.slice;\n    if (!this.support) {\n      throw new Error('Not supported by Browser');\n    }\n  }\n\n  /**\n   * Assign the attributes of this instance via destructuring of the options object.\n   */\n  protected setInstanceProperties(options: ResumableConfiguration) {\n    Object.assign(this, options);\n    this.sanitizeFileTypes();\n  }\n\n  private sanitizeFileTypes(): void {\n    // For good behaviour we do some sanitizing. Remove spaces and dots and lowercase all.\n    this.fileTypes = this.fileTypes.map((type) => type.replace(/[\\s.]/g, '').toLowerCase());\n  }\n\n  /**\n   * Transforms a single fileEntry or directoryEntry item into a list of File objects this method is used to convert\n   * entries found inside dragged-and-dropped directories.\n   * @param {Object} item item to upload, may be file or directory entry\n   * @param {string} path current file path\n   */\n  private async mapDirectoryItemToFile(item: FileSystemEntry, path: string): Promise<File[]> {\n    if (item.isFile) {\n      // file entry provided\n      const file = await new Promise(\n        (resolve, reject) => (item as FileSystemFileEntry).file(resolve, reject)\n      ) as ExtendedFile;\n      file.relativePath = path + file.name;\n      return [file];\n    } else if (item.isDirectory) {\n      // directory entry provided\n      return await this.processDirectory(item as FileSystemDirectoryEntry, path + item.name + '/');\n    } else if (item instanceof File) {\n      return [item];\n    }\n\n    console.warn('Item mapping did not return a file object. This might be due to an unknown file type.')\n    return [];\n  }\n\n  /**\n   * Transforms a single DataTransfer item into a File object. This may include either extracting the given file or\n   * all files inside the provided directory.\n   * @param item item to upload, may be file or directory entry\n   * @param path current file path\n   */\n  private async mapDragItemToFile(item: DataTransferItem, path: string): Promise<File[]> {\n    let entry = item.webkitGetAsEntry();\n    if (entry.isDirectory) {\n      return await this.processDirectory(entry as FileSystemDirectoryEntry, path + entry.name + '/');\n    }\n\n    let file = item.getAsFile();\n    if (file instanceof File) {\n      (file as ExtendedFile).relativePath = path + file.name;\n      return [file];\n    }\n\n    console.warn('Item mapping did not return a file object. This might be due to an unknown file type.')\n    return [];\n  }\n\n  /**\n   * Recursively traverse a directory and collect files to upload\n   */\n  private processDirectory(directory: FileSystemDirectoryEntry, path: string): Promise<File[]> {\n    return new Promise((resolve, reject) => {\n      const dirReader = directory.createReader();\n      let allEntries = [];\n\n      const readEntries = (): void => {\n        dirReader.readEntries(async (entries: FileSystemEntry[]): Promise<void> => {\n          // Read the files batch-wise (in chrome e.g. 100 at a time)\n          if (entries.length) {\n            allEntries = allEntries.concat(entries);\n            return readEntries();\n          }\n\n          // After collecting all files, map all fileEntries to File objects\n          allEntries = allEntries.map((entry) => {\n            return this.mapDirectoryItemToFile(entry, path);\n          });\n          // Wait until all files are collected.\n          resolve(await Promise.all(allEntries));\n        }, reject);\n      };\n\n      readEntries();\n    });\n  }\n\n  /**\n   * If \"assignDrop\" was used to assign the drop events to an element, we automatically add the \"dragOverClass\" CSS\n   * class to the element when a file is dropped onto it. In this case, we have to remove that class again before\n   * calling \"onDrop()\".\n   * If \"onDrop()\" is called from \"handleDropEvent()\" this is not needed.\n   * \n   */\n  private removeDragOverClassAndCallOnDrop(e: DragEvent): Promise<void> {\n    (e.currentTarget as HTMLElement).classList.remove(this.dragOverClass);\n\n    return this.onDrop(e);\n  }\n\n  /**\n   * Handle the event when a new file was provided via drag-and-drop\n   */\n  private async onDrop(e: DragEvent): Promise<void> {\n    Helpers.stopEvent(e);\n\n    let items = [];\n\n    //handle dropped things as items if we can (this lets us deal with folders nicer in some cases)\n    if (e.dataTransfer && e.dataTransfer.items) {\n      items = [...e.dataTransfer.items as any];\n    }\n    //else handle them as files\n    else if (e.dataTransfer && e.dataTransfer.files) {\n      items =  [...e.dataTransfer.files as any];\n    }\n\n    if (!items.length) {\n      return; // nothing to do\n    }\n    this.fire('fileProcessingBegin', items);\n    let promises = items.map((item) => this.mapDragItemToFile(item, ''));\n    let files = Helpers.flattenDeep(await Promise.all(promises));\n    if (files.length) {\n      // at least one file found\n      this.appendFilesFromFileList(files, e);\n    }\n  }\n\n  /**\n   * Handle the event when a drag-and-drop item leaves the area of assigned drag-and-drop area\n   */\n  private onDragLeave(e: DragEvent): void {\n    (e.currentTarget as HTMLElement).classList.remove(this.dragOverClass);\n  }\n\n  /**\n   * Handle the event when a drag-and-drop item enters the area of assigned drag-and-drop area\n   */\n  private onDragOverEnter(e: DragEvent): void {\n    e.preventDefault();\n    let dt = e.dataTransfer;\n    if (dt.types.includes('Files')) { // only for file drop\n      e.stopPropagation();\n      dt.dropEffect = 'copy';\n      dt.effectAllowed = 'copy';\n      (e.currentTarget as HTMLElement).classList.add(this.dragOverClass);\n    } else {\n      dt.dropEffect = 'none';\n      dt.effectAllowed = 'none';\n    }\n  };\n\n  /**\n   * Validate and clean a list of files. This includes the removal of duplicates, a check whether the file type is\n   * allowed and custom validation functions defined per file type.\n   * @param {ExtendedFile[]} files A list of File instances that were previously extended with a uniqueIdentifier\n   */\n  private async validateFiles(files: ExtendedFile[]): Promise<ExtendedFile[]> {\n    // Remove files that are duplicated in the original array, based on their unique identifiers\n    let uniqueFiles = Helpers.uniqBy(files,\n      (file) => file.uniqueIdentifier,\n      (file) => this.fire('fileProcessingFailed', file, 'duplicate'),\n    );\n\n    let validationPromises = uniqueFiles.map(async (file) => {\n      // Remove files that were already added based on their unique identifiers\n      if (this.files.some((addedFile) => addedFile.uniqueIdentifier === file.uniqueIdentifier)) {\n        this.fire('fileProcessingFailed', file, 'duplicate');\n        return false;\n      }\n\n      let fileType: string = file.type.toLowerCase();\n      let fileExtension = file.name.split('.').pop().toLowerCase();\n\n      if (this.fileTypes.length > 0) {\n        const fileTypeFound = this.fileTypes.some((type) => {\n          // Check whether the extension inside the filename is an allowed file type\n          return fileExtension === type ||\n            // If MIME type, check for wildcard or if extension matches the file's tile type\n            type.includes('/') && (\n              type.includes('*') &&\n              fileType.substring(0, type.indexOf('*')) === type.substring(0, type.indexOf('*')) ||\n              fileType === type\n            );\n        });\n        if (!fileTypeFound) {\n          this.fire('fileProcessingFailed', file, 'fileType');\n          this.fileTypeErrorCallback(file);\n          return false;\n        }\n      }\n\n      // Validate the file size against minimum and maximum allowed sizes\n      if (this.minFileSize !== undefined && file.size < this.minFileSize) {\n        this.fire('fileProcessingFailed', file, 'minFileSize');\n        this.minFileSizeErrorCallback(file);\n        return false;\n      }\n      if (this.maxFileSize !== undefined && file.size > this.maxFileSize) {\n        this.fire('fileProcessingFailed', file, 'maxFileSize');\n        this.maxFileSizeErrorCallback(file);\n        return false;\n      }\n\n      // Apply a custom validator based on the file extension\n      if (fileExtension in this.validators && !await this.validators[fileExtension](file)) {\n        this.fire('fileProcessingFailed', file, 'validation');\n        this.fileValidationErrorCallback(file);\n        return false;\n      }\n\n      return true;\n    });\n\n    const results = await Promise.all(validationPromises);\n\n    // Only include files that passed their validation tests\n    return files.filter((_v, index) => results[index]);\n  }\n\n  /**\n   * Add an array of files to this instance's file list by creating new ResumableFiles. This includes a validation and\n   * deduplication of the provided array.\n   * @param fileList An array containing File objects\n   * @param event The event with which the fileList was provided\n   */\n  private async appendFilesFromFileList(fileList: File[], event: Event): Promise<boolean> {\n    // check for uploading too many files\n    if (this.maxFiles !== undefined && this.maxFiles < fileList.length + this.files.length) {\n      // if single-file upload, file is already added, and trying to add 1 new file, simply replace the already-added file\n      if (this.maxFiles === 1 && this.files.length === 1 && fileList.length === 1) {\n        this.removeFile(this.files[0]);\n      } else {\n        this.fire('fileProcessingFailed', undefined, 'maxFiles');\n        this.maxFilesErrorCallback(fileList);\n        return false;\n      }\n    }\n\n    // Add the unique identifier for every new file.\n    // Since this might return a promise, we have to wait until it completed.\n    const filesWithUniqueIdentifiers = await Promise.all(fileList.map(async (file: ExtendedFile): Promise<ExtendedFile> => {\n      file.uniqueIdentifier = await this.generateUniqueIdentifier(file, event);\n      return file;\n    }));\n\n    // Validate the files and remove duplicates\n    const validatedFiles = await this.validateFiles(filesWithUniqueIdentifiers);\n\n    let skippedFiles = filesWithUniqueIdentifiers.filter((file) => !validatedFiles.includes(file));\n\n    for (const file of validatedFiles) {\n      let f = new ResumableFile(file, file.uniqueIdentifier, this.opts);\n      f.on('chunkSuccess', () => this.handleChunkSuccess());\n      f.on('chunkError', () => this.handleChunkError());\n      f.on('chunkCancel', () => this.handleChunkCancel());\n      f.on('fileProgress', (...args) => this.handleFileProgress(args));\n      f.on('fileError', (...args) => this.handleFileError(args));\n      f.on('fileSuccess', (...args) => this.handleFileSuccess(args));\n      f.on('fileCancel', (...args) => this.handleFileCancel(args));\n      f.on('fileRetry', () => this.handleFileRetry());\n      this.files.push(f);\n      this.fire('fileAdded', f, event);\n    }\n\n    // all files processed, trigger event\n    if (!validatedFiles.length && !skippedFiles.length) {\n      // no succeeded files, just skip\n      return;\n    }\n    this.fire('filesAdded', validatedFiles, skippedFiles);\n  }\n\n  /**\n   * Generate a new unique identifier for a given file either with a default helper function or with a custom\n   * generator function.\n   * @param file The file as an HTML 5 File object\n   * @param event The event with which the file was provided originally\n   */\n  private generateUniqueIdentifier(file: File, event: Event): string {\n    return typeof this._generateUniqueIdentifier === 'function' ?\n      this._generateUniqueIdentifier(file, event) : Helpers.generateUniqueIdentifier(file);\n  }\n\n  /**\n   * Queue a new chunk to be uploaded that is currently awaiting upload.\n   */\n  private uploadNextChunk(): void {\n    // In some cases (such as videos) it's really handy to upload the first\n    // and last chunk of a file quickly; this lets the server check the file's\n    // metadata and determine if there's even a point in continuing.\n    if (this.prioritizeFirstAndLastChunk) {\n      for (const file of this.files) {\n        if (file.chunks.length && file.chunks[0].status === ResumableChunkStatus.PENDING) {\n          file.chunks[0].send();\n          return;\n        }\n        if (file.chunks.length > 1 && file.chunks[file.chunks.length - 1].status === ResumableChunkStatus.PENDING) {\n          file.chunks[file.chunks.length - 1].send();\n          return;\n        }\n      }\n    }\n\n    // Now, simply look for the next best thing to upload\n    for (const file of this.files) {\n      if (file.upload()) return;\n    }\n  }\n\n  /**\n   *  PUBLIC METHODS FOR RESUMABLE.JS\n   *  This section only includes methods that should be callable from external packages.\n   */\n\n  /**\n   * Assign a browse action to one or more DOM nodes. Pass in true to allow directories to be selected (Chrome only).\n   */\n  assignBrowse(domNodes: HTMLElement | HTMLElement[], isDirectory: boolean = false): void {\n    if (domNodes instanceof HTMLElement) domNodes = [domNodes];\n    for (const domNode of domNodes) {\n      let input;\n      if (domNode instanceof HTMLInputElement && domNode.type === 'file') {\n        input = domNode;\n      } else {\n        input = document.createElement('input');\n        input.setAttribute('type', 'file');\n        input.style.display = 'none';\n        domNode.addEventListener('click', () => {\n          input.style.opacity = 0;\n          input.style.display = 'block';\n          input.focus();\n          input.click();\n          input.style.display = 'none';\n        }, false);\n        domNode.appendChild(input);\n      }\n      if (this.maxFiles !== 1) {\n        input.setAttribute('multiple', 'multiple');\n      } else {\n        input.removeAttribute('multiple');\n      }\n      if (isDirectory) {\n        input.setAttribute('webkitdirectory', 'webkitdirectory');\n      } else {\n        input.removeAttribute('webkitdirectory');\n      }\n      this.setFileTypes(this.fileTypes, input);\n      // When new files are added, simply append them to the overall list\n      input.addEventListener('change', this.handleChangeEvent.bind(this), false);\n    }\n  }\n\n  /**\n   * Assign one or more DOM nodes as a drop target.\n   */\n  assignDrop(domNodes: HTMLElement | HTMLElement[]): void {\n    if (domNodes instanceof HTMLElement) domNodes = [domNodes];\n\n    for (const domNode of domNodes) {\n      domNode.addEventListener('dragover', this.onDragOverEnter.bind(this), false);\n      domNode.addEventListener('dragenter', this.onDragOverEnter.bind(this), false);\n      domNode.addEventListener('dragleave', this.onDragLeave.bind(this), false);\n      domNode.addEventListener('drop', this.removeDragOverClassAndCallOnDrop.bind(this), false);\n    }\n  }\n\n  /**\n   * Remove one or more DOM nodes as a drop target.\n   */\n  unAssignDrop(domNodes: HTMLElement | HTMLElement[]): void {\n    if (domNodes instanceof HTMLElement) domNodes = [domNodes];\n\n    for (const domNode of domNodes) {\n      domNode.removeEventListener('dragover', this.onDragOverEnter.bind(this));\n      domNode.removeEventListener('dragenter', this.onDragOverEnter.bind(this));\n      domNode.removeEventListener('dragleave', this.onDragLeave.bind(this));\n      domNode.removeEventListener('drop', this.removeDragOverClassAndCallOnDrop.bind(this));\n    }\n  }\n\n  /**\n   * Set the file types allowed to upload. Optionally pass a dom node on which the accepted file types should be\n   * updated as well.\n   */\n  setFileTypes(fileTypes: string[], domNode: HTMLInputElement = null): void {\n    if (domNode && domNode.type !== 'file') {\n      throw new Error('Dom node is not a file input.');\n    }\n\n    // Store new file types and sanitize them.\n    this.fileTypes = fileTypes;\n    this.sanitizeFileTypes();\n\n    if (domNode) {\n      if (fileTypes.length >= 1) {\n        // Set the new file types as \"accepted\" by the given dom node.\n        domNode.setAttribute('accept', this.fileTypes.map((type) => {\n          if (type.match(/^[^.][^/]+$/)) {\n            type = '.' + type;\n          }\n          return type;\n        }).join(','));\n      } else {\n        // Make all file types \"accepted\" by the given dom node.\n        domNode.removeAttribute('accept');\n      }\n    }\n  }\n\n  /**\n   * Check whether any files are currently uploading\n   */\n  get isUploading(): boolean {\n    return this.files.some((file) => file.isUploading);\n  }\n\n  /**\n   * Start or resume the upload of the provided files by initiating the upload of the first chunk\n   */\n  upload(): void {\n    // Make sure we don't start too many uploads at once\n    if (this.isUploading) return;\n    // Kick off the queue\n    this.fire('uploadStart');\n    for (let num = 1; num <= this.simultaneousUploads; num++) {\n      this.uploadNextChunk();\n    }\n  }\n\n  /**\n   * Pause the upload\n   */\n  pause(): void {\n    // Resume all chunks currently being uploaded\n    for (const file of this.files) {\n      file.abort();\n    }\n    this.fire('pause');\n  };\n\n  /**\n   * Cancel uploading and reset all files to their initial states\n   */\n  cancel(): void {\n    this.fire('beforeCancel');\n    for (let i = this.files.length - 1; i >= 0; i--) {\n      this.files[i].cancel();\n    }\n    this.fire('cancel');\n  };\n\n  /**\n   * Return the progress of the current upload as a float between 0 and 1\n   */\n  progress(): number {\n    let totalDone = this.files.reduce((accumulator, file) => accumulator + file.size * file.progress(), 0);\n    let totalSize = this.getSize();\n    return totalSize > 0 ? totalDone / totalSize : 0;\n  };\n\n  /**\n   * Add a HTML5 File object to the list of files.\n   */\n  addFile(file: File, event: Event): void {\n    this.appendFilesFromFileList([file], event);\n  };\n\n  /**\n   * Add a list of HTML5 File objects to the list of files.\n   */\n  addFiles(files: File[], event: Event): void {\n    this.appendFilesFromFileList(files, event);\n  };\n\n  /**\n   * Add a validator function for the given file type. This can e.g. be used to read the file and validate\n   * checksums based on certain properties.\n   * @param fileType The file extension for the given validator\n   * @param validator A callback function that should be called when validating files with the given type\n   */\n  addFileValidator(fileType: string, validator: Function): void {\n    if (fileType in this.validators) {\n      console.warn(`Overwriting validator for file type: ${fileType}`);\n    }\n    this.validators[fileType] = validator;\n  }\n\n  /**\n   * Cancel the upload of a specific ResumableFile object and remove it from the file list.\n   */\n  removeFile(file: ResumableFile): void {\n    for (let i = this.files.length - 1; i >= 0; i--) {\n      if (this.files[i] === file) {\n        this.files.splice(i, 1);\n        break;\n      }\n    }\n  };\n\n  /**\n   * Retrieve a ResumableFile object from the file list by its unique identifier.\n   */\n  getFromUniqueIdentifier(uniqueIdentifier: string): ResumableFile {\n    return this.files.find((file) => file.uniqueIdentifier === uniqueIdentifier);\n  };\n\n  /**\n   * Get the combined size of all files for the upload\n   */\n  getSize(): number {\n    return this.files.reduce((accumulator, file) => accumulator + file.size, 0);\n  }\n\n  /**\n   * Call the event handler for a DragEvent (when a file is dropped on a drop area).\n   */\n  handleDropEvent(e: DragEvent): void {\n    this.onDrop(e);\n  }\n\n  /**\n   * Call the event handler for an InputEvent (i.e. received one or multiple files).\n   */\n  handleChangeEvent(e: InputEvent): void {\n    const eventTarget = e.target as HTMLInputElement;\n    this.fire('fileProcessingBegin', eventTarget.files);\n    this.appendFilesFromFileList([...eventTarget.files as any], e);\n    if (this.clearInput) {\n      eventTarget.value = '';\n    }\n  }\n\n  /**\n   * Check whether the upload is completed, i.e. if all files were uploaded successfully.\n   */\n  checkUploadComplete(): void {\n    let uploadCompleted = this.files.every((file) => file.isComplete);\n    if (uploadCompleted) {\n      // All chunks have been uploaded, complete\n      this.fire('complete');\n    }\n  }\n\n  /**\n   * Event Handlers: This section should only include methods that are used to\n   * handle events coming from the files or chunks.\n   */\n\n  /**\n   * The event handler when a chunk was uploaded successfully\n   */\n  private handleChunkSuccess(): void {\n    this.uploadNextChunk();\n  }\n\n  /**\n   * The event handler when a chunk was uploaded successfully\n   */\n  private handleChunkError(): void {\n    this.uploadNextChunk();\n  }\n\n  /**\n   * The event handler when an error occurred during the upload of a chunk\n   */\n  private handleChunkCancel(): void {\n    this.uploadNextChunk();\n  }\n\n  /**\n   * The event handler when an error occurred during the upload of a file\n   */\n  private handleFileError(args: any[]): void {\n    this.fire('error', args[1], args[0]);\n  }\n\n  /**\n   * The event handler when all chunks from a file were uploaded successfully\n   */\n  private handleFileSuccess(args: any[]): void {\n    this.fire('fileSuccess', ...args);\n    this.checkUploadComplete();\n  }\n\n  /**\n   * The event handler when a file progress event was received\n   */\n  private handleFileProgress(args: any[]): void {\n    this.fire('fileProgress', ...args);\n    this.fire('progress');\n  }\n\n  /**\n   * The event handler when the upload of a file was canceled\n   */\n  private handleFileCancel(args: any[]): void {\n    this.removeFile(args[0])\n  }\n\n  /**\n   * The event handler, when the retry of a file was initiated\n   */\n  private handleFileRetry(): void {\n    this.upload();\n  }\n}\n","import Helpers from './resumableHelpers';\nimport ResumableEventHandler from './resumableEventHandler';\nimport ResumableFile from './resumableFile';\nimport {ResumableChunkStatus, ResumableConfiguration} from './types/types';\n\n/**\n * A file chunk that contains all the data that for a single upload request\n */\nexport default class ResumableChunk extends ResumableEventHandler {\n  private fileObj: ResumableFile;\n  private fileObjSize: number;\n  private fileObjType: string;\n  private offset: number;\n  private lastProgressCallback: Date = new Date;\n  private tested: boolean = false;\n  private retries: number = 0;\n  private pendingRetry: boolean = false;\n  private isMarkedComplete: boolean = false;\n  private loaded: number = 0;\n  private startByte: number;\n  private endByte: number;\n  private xhr: XMLHttpRequest = null;\n\n  // Option properties\n  private chunkSize: number = 1024 * 1024; // 1 MB\n  private fileParameterName: string = 'file';\n  chunkNumberParameterName: string = 'resumableChunkNumber';\n  chunkSizeParameterName: string = 'resumableChunkSize';\n  currentChunkSizeParameterName: string = 'resumableCurrentChunkSize';\n  totalSizeParameterName: string = 'resumableTotalSize';\n  typeParameterName: string = 'resumableType';\n  identifierParameterName: string = 'resumableIdentifier';\n  fileNameParameterName: string = 'resumableFilename';\n  relativePathParameterName: string = 'resumableRelativePath';\n  totalChunksParameterName: string = 'resumableTotalChunks';\n  throttleProgressCallbacks: number = 0.5;\n  query: object = {};\n  headers: object = {};\n  method: string = 'multipart';\n  uploadMethod: string = 'POST';\n  testMethod: string = 'GET';\n  parameterNamespace: string = '';\n  testChunks: boolean = true;\n  maxChunkRetries: number = 100;\n  chunkRetryInterval?: number = undefined;\n  permanentErrors: number[] = [400, 401, 403, 404, 409, 415, 500, 501];\n  withCredentials: boolean = false;\n  xhrTimeout: number = 0;\n  chunkFormat: string = 'blob';\n  setChunkTypeFromFile: boolean = false;\n  target: string = '/';\n  testTarget: string = '';\n\n\n  constructor(fileObj: ResumableFile, offset: number, options: ResumableConfiguration) {\n    super();\n    this.setInstanceProperties(options);\n    this.fileObj = fileObj;\n    this.fileObjSize = fileObj.size;\n    this.fileObjType = fileObj.file.type;\n    this.offset = offset;\n\n    // Computed properties\n    this.startByte = this.offset * this.chunkSize;\n    this.endByte = Math.min(this.fileObjSize, (this.offset + 1) * this.chunkSize);\n    this.xhr = null;\n  }\n\n  /**\n   * Set the options provided inside the configuration object on this instance\n   */\n  protected setInstanceProperties(options: ResumableConfiguration): void {\n    Object.assign(this, options);\n  }\n\n  /**\n   * Set the header values for the current XMLHttpRequest\n   */\n  setCustomHeaders(): void {\n    if (!this.xhr) {\n      return;\n    }\n    let customHeaders = this.headers;\n    if (customHeaders instanceof Function) {\n      customHeaders = customHeaders(this.fileObj, this);\n    }\n    for (const header in customHeaders) {\n      if (!customHeaders.hasOwnProperty(header)) continue;\n      this.xhr.setRequestHeader(header, customHeaders[header]);\n    }\n  }\n\n  /**\n   * Get query parameters for this chunk as an object, combined with custom parameters if provided\n   */\n  get formattedQuery(): object {\n    var customQuery = this.query;\n    if (typeof customQuery == 'function') customQuery = customQuery(this.fileObj, this);\n\n    // Add extra data to identify chunk\n    const extraData = {\n      // define key/value pairs for additional parameters\n      [this.chunkNumberParameterName]: this.offset + 1,\n      [this.chunkSizeParameterName]: this.chunkSize,\n      [this.currentChunkSizeParameterName]: this.endByte - this.startByte,\n      [this.totalSizeParameterName]: this.fileObjSize,\n      [this.typeParameterName]: this.fileObjType,\n      [this.identifierParameterName]: this.fileObj.uniqueIdentifier,\n      [this.fileNameParameterName]: this.fileObj.fileName,\n      [this.relativePathParameterName]: this.fileObj.relativePath,\n      [this.totalChunksParameterName]: this.fileObj.chunks.length,\n    };\n    return {...extraData, ...customQuery};\n  }\n\n  /**\n   * Determine the status for this Chunk based on different parameters of the underlying XMLHttpRequest\n   */\n  get status(): ResumableChunkStatus {\n    if (this.pendingRetry) {\n      // if pending retry then that's effectively the same as actively uploading,\n      // there might just be a slight delay before the retry starts\n      return ResumableChunkStatus.UPLOADING;\n    } else if (this.isMarkedComplete) {\n      return ResumableChunkStatus.SUCCESS;\n    } else if (!this.xhr) {\n      return ResumableChunkStatus.PENDING;\n    } else if (this.xhr.readyState < 4) {\n      // Status is really 'OPENED', 'HEADERS_RECEIVED' or 'LOADING' - meaning that stuff is happening\n      return ResumableChunkStatus.UPLOADING;\n    } else if (this.xhr.status === 200 || this.xhr.status === 201) {\n      // HTTP 200, 201 (created)\n      return ResumableChunkStatus.SUCCESS;\n    } else if (this.permanentErrors.includes(this.xhr.status) || this.retries >= this.maxChunkRetries) {\n      // HTTP 400, 404, 409, 415, 500, 501 (permanent error)\n      return ResumableChunkStatus.ERROR;\n    } else {\n      // this should never happen, but we'll reset and queue a retry\n      // a likely case for this would be 503 service unavailable\n      this.abort();\n      return ResumableChunkStatus.PENDING;\n    }\n  };\n\n  /**\n   * Get the target url for the specified request type and the configured parameters of this chunk\n   * @param requestType The type of the request, either 'test' or 'upload'\n   */\n  getTarget(requestType: string): string {\n    return Helpers.getTarget(requestType, this.target, this.testTarget, this.formattedQuery, this.parameterNamespace);\n  }\n\n  /**\n   * Makes a GET request without any data to see if the chunk has already been uploaded in a previous session\n   */\n  test(): void {\n    // Set up request and listen for event\n    this.xhr = new XMLHttpRequest();\n\n    var testHandler = () => {\n      this.tested = true;\n      var status = this.status;\n      if (status === ResumableChunkStatus.SUCCESS) {\n        this.fire('chunkSuccess', this.message());\n      } else {\n        this.send();\n      }\n    };\n    this.xhr.addEventListener('load', testHandler, false);\n    this.xhr.addEventListener('error', testHandler, false);\n    this.xhr.addEventListener('timeout', testHandler, false);\n\n    // Append the relevant chunk and send it\n    this.xhr.open(this.testMethod, this.getTarget('test'));\n    this.xhr.timeout = this.xhrTimeout;\n    this.xhr.withCredentials = this.withCredentials;\n    // Add data from header options\n    this.setCustomHeaders();\n\n    this.xhr.send(null);\n  }\n\n  /**\n   * Abort and reset a request\n   */\n  abort(): void {\n    if (this.xhr) this.xhr.abort();\n    this.xhr = null;\n  }\n\n  /**\n   *  Uploads the actual data in a POST call\n   */\n  send(): void {\n    if (this.testChunks && !this.tested) {\n      this.test();\n      return;\n    }\n\n    // Set up request and listen for event\n    this.xhr = new XMLHttpRequest();\n\n    // Progress\n    this.xhr.upload.addEventListener('progress', (e: ProgressEvent<XMLHttpRequestEventTarget>) => {\n      if (Date.now() - this.lastProgressCallback.getTime() > this.throttleProgressCallbacks * 1000) {\n        this.fire('chunkProgress');\n        this.lastProgressCallback = new Date();\n      }\n      this.loaded = e.loaded || 0;\n    }, false);\n    this.loaded = 0;\n    this.pendingRetry = false;\n    this.fire('chunkProgress');\n\n    /**\n     * Handles the different xhr events based on the status of this chunk\n     */\n    let doneHandler = () => {\n      var status = this.status;\n      switch (status) {\n        case ResumableChunkStatus.SUCCESS:\n        case ResumableChunkStatus.ERROR:\n          this.fire(status, this.message());\n          break;\n        default:\n          this.fire('chunkRetry', this.message());\n          this.abort();\n          this.retries++;\n          let retryInterval = this.chunkRetryInterval;\n          if (retryInterval !== undefined) {\n            this.pendingRetry = true;\n            setTimeout(this.send, retryInterval);\n          } else {\n            this.send();\n          }\n          break;\n      }\n    };\n    this.xhr.addEventListener('load', doneHandler, false);\n    this.xhr.addEventListener('error', doneHandler, false);\n    this.xhr.addEventListener('timeout', doneHandler, false);\n\n    // Set up the basic query data from Resumable\n    let bytes = this.fileObj.file.slice(this.startByte, this.endByte,\n      this.setChunkTypeFromFile ? this.fileObj.file.type : '');\n    let data = null;\n    let parameterNamespace = this.parameterNamespace;\n    // Add data from the query options\n    if (this.method === 'octet') {\n      data = bytes;\n    } else {\n      data = new FormData();\n      for (const queryKey in this.formattedQuery) {\n        data.append(parameterNamespace + queryKey, this.formattedQuery[queryKey]);\n      }\n      switch (this.chunkFormat) {\n        case 'blob':\n          data.append(parameterNamespace + this.fileParameterName, bytes, this.fileObj.fileName);\n          break;\n        case 'base64':\n          var fr = new FileReader();\n          fr.onload = () => {\n            data.append(parameterNamespace + this.fileParameterName, fr.result);\n            this.xhr.send(data);\n          };\n          fr.readAsDataURL(bytes);\n          break;\n      }\n    }\n\n    let target = this.getTarget('upload');\n\n    this.xhr.open(this.uploadMethod, target);\n    if (this.method === 'octet') {\n      this.xhr.setRequestHeader('Content-Type', 'application/octet-stream');\n    }\n    this.xhr.timeout = this.xhrTimeout;\n    this.xhr.withCredentials = this.withCredentials;\n    // Add data from header options\n    this.setCustomHeaders();\n\n    if (this.chunkFormat === 'blob') {\n      this.xhr.send(data);\n    }\n  }\n\n  /**\n   * Return the response text of the underlying XMLHttpRequest if it exists\n   */\n  message(): string {\n    return this.xhr ? this.xhr.responseText : '';\n  };\n\n  /**\n   * Return the progress for the current chunk as a number between 0 and 1\n   * @param relative Whether or not the progress should be calculated based on the size of the entire file\n   */\n  progress(relative: boolean = false): number {\n    var factor = relative ? (this.endByte - this.startByte) / this.fileObjSize : 1;\n    if (this.pendingRetry) return 0;\n    if ((!this.xhr || !this.xhr.status) && !this.isMarkedComplete) factor *= .95;\n    switch (this.status) {\n      case ResumableChunkStatus.SUCCESS:\n      case ResumableChunkStatus.ERROR:\n        return factor;\n      case ResumableChunkStatus.PENDING:\n        return 0;\n      default:\n        return this.loaded / (this.endByte - this.startByte) * factor;\n    }\n  }\n\n  /**\n   * Mark this chunk as completed because it was already uploaded to the server.\n   */\n  markComplete(): void {\n    this.isMarkedComplete = true;\n  }\n}\n","/**\n * The underlying base class for ResumableJS. This class is responsible for registering and executing\n * events and listeners.\n */\nexport default class ResumableEventHandler {\n  private registeredEventHandlers: { [event: string]: Function[]};\n\n  /**\n   * Construct a new event handler instance.\n   */\n  constructor() {\n    this.registeredEventHandlers = {};\n  }\n\n  /**\n   * Register a new callback for the given event.\n   */\n  on(event: string, callback: Function): void {\n    event = event.toLowerCase();\n    if (!this.registeredEventHandlers.hasOwnProperty(event)) {\n      this.registeredEventHandlers[event] = [];\n    }\n    this.registeredEventHandlers[event].push(callback);\n  }\n\n  /**\n   * Fire the event listeners for the given event with the given arguments as well as the wildcard event '*'\n   */\n  fire(event: string, ...args): void {\n    event = event.toLowerCase();\n\n    this.executeEventCallback(event, ...args);\n    this.executeEventCallback('*', event, ...args);\n  }\n\n  /**\n   * Execute all callbacks for the given event with the provided arguments. This function is only used internally\n   * to call all callbacks registered to a given event individually.\n   */\n  private executeEventCallback(event: string, ...args): void {\n    if (!this.registeredEventHandlers.hasOwnProperty(event)) return;\n    this.registeredEventHandlers[event].forEach((callback) => callback(...args));\n  }\n}\n","import ResumableChunk from './resumableChunk';\nimport Helpers from './resumableHelpers';\nimport ResumableEventHandler from './resumableEventHandler';\nimport {ResumableChunkStatus, ResumableConfiguration} from './types/types';\n\n/**\n * A single file object that should be uploaded in multiple chunks\n */\nexport default class ResumableFile extends ResumableEventHandler {\n  private opts: ResumableConfiguration;\n  private _prevProgress: number = 0;\n  private isPaused: boolean = false;\n\n  file: File;\n  fileName: string;\n  size: number;\n  relativePath: string;\n  uniqueIdentifier: string;\n  private _error: boolean;\n  chunks: ResumableChunk[] = [];\n  private chunkSize: number = 1024 * 1024; // 1 MB\n\n  constructor(file: File, uniqueIdentifier: string, options: object) {\n    super();\n    this.opts = options;\n    this.setInstanceProperties(options);\n    this.file = file;\n    this.fileName = file.name;\n    this.size = file.size;\n    this.relativePath = /*file.relativePath ||*/ file.webkitRelativePath || this.fileName;\n    this.uniqueIdentifier = uniqueIdentifier;\n    this._error = uniqueIdentifier !== undefined;\n\n    // Bootstrap file\n    this.fire('chunkingStart', this);\n    this.bootstrap();\n  }\n\n  /**\n   * Set the options provided inside the configuration object on this instance\n   */\n  protected setInstanceProperties(options: ResumableConfiguration) {\n    Object.assign(this, options);\n  }\n\n  /**\n   * Stop current uploads for this file\n   */\n  abort(): void {\n    let abortCount = 0;\n    for (const chunk of this.chunks) {\n      if (chunk.status === ResumableChunkStatus.UPLOADING) {\n        chunk.abort();\n        abortCount++;\n      }\n    }\n    if (abortCount > 0) this.fire('fileProgress', this);\n  }\n\n  /**\n   * Cancel uploading this file and remove it from the file list\n   */\n  cancel(): void {\n    for (const chunk of this.chunks) {\n      if (chunk.status === ResumableChunkStatus.UPLOADING) {\n        chunk.abort();\n        this.fire('chunkCancel', chunk);\n      }\n    }\n    // Reset this file to be void\n    this.chunks = [];\n    this.fire('fileCancel', this);\n    this.fire('fileProgress', this);\n  }\n\n  /**\n   * Retry uploading this file\n   */\n  retry(): void {\n    this.bootstrap();\n    let firedRetry = false;\n    this.on('chunkingComplete', () => {\n      if (!firedRetry) this.fire('fileRetry');\n      firedRetry = true;\n    });\n  }\n\n  /**\n   * Prepare this file for a new upload, by dividing it into multiple chunks\n   */\n  bootstrap(): void {\n    const progressHandler = (message) => this.fire('fileProgress', this, message);\n    const retryHandler = () =>  this.fire('fileRetry', this);\n    const successHandler = (message) => {\n      if (this._error) return;\n      this.fire('chunkSuccess');\n      this.fire('fileProgress', this, message); // it's at least progress\n      if (this.isComplete) {\n        this.fire('fileSuccess', this, message);\n      }\n    };\n    const errorHandler = (message) => {\n      this.fire('chunkError', message);\n      this.abort();\n      this._error = true;\n      this.chunks = [];\n      this.fire('fileError', this, message);\n    }\n\n    this.abort();\n    this._error = false;\n    // Rebuild stack of chunks from file\n    this.chunks = [];\n    this._prevProgress = 0;\n    const maxOffset = Math.max(Math.ceil(this.file.size / this.chunkSize), 1);\n    for (var offset = 0; offset < maxOffset; offset++) {\n      const chunk = new ResumableChunk(this, offset, this.opts);\n      chunk.on('chunkProgress', progressHandler);\n      chunk.on('chunkError', errorHandler);\n      chunk.on('chunkSuccess', successHandler);\n      chunk.on('chunkRetry', retryHandler);\n      this.chunks.push(chunk);\n      this.fire('chunkingProgress', this, offset / maxOffset);\n    }\n    this.fire('chunkingComplete', this);\n  }\n\n  /**\n   * Get the progress for uploading this file based on the progress of the individual file chunks\n   */\n  progress(): number {\n    if (this._error) return 1;\n    // Sum up progress across everything\n    var ret = 0;\n    var error = false;\n    for (const chunk of this.chunks) {\n      if (chunk.status === ResumableChunkStatus.ERROR) error = true;\n      ret += chunk.progress(true); // get chunk progress relative to entire file\n    }\n    ret = error ? 1 : (ret > 0.99999 ? 1 : ret);\n    ret = Math.max(this._prevProgress, ret); // We don't want to lose percentages when an upload is paused\n    this._prevProgress = ret;\n    return ret;\n  }\n\n  /**\n   * Check whether at least one of this file's chunks is currently uploading\n   */\n  get isUploading(): boolean {\n    return this.chunks.some((chunk) => chunk.status === ResumableChunkStatus.UPLOADING);\n  }\n\n  /**\n   * Check whether all of this file's chunks completed their upload requests and whether it should be\n   * treated as completed.\n   */\n  get isComplete(): boolean {\n    return !this.chunks.some((chunk) =>\n      chunk.status === ResumableChunkStatus.PENDING || chunk.status === ResumableChunkStatus.UPLOADING);\n  }\n\n  /**\n   * Initiate the upload of a new chunk for this file. This function returns whether a new upload was started or not.\n   */\n  upload(): boolean {\n    if (this.isPaused) {\n      return false;\n    }\n\n    for (const chunk of this.chunks) {\n      if (chunk.status === ResumableChunkStatus.PENDING) {\n        chunk.send();\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Mark a given number of chunks as already uploaded to the server.\n   * @param chunkNumber The index until which all chunks should be marked as completed\n   */\n  markChunksCompleted(chunkNumber: number): void {\n    if (!this.chunks || this.chunks.length <= chunkNumber) {\n      return;\n    }\n    for (let num = 0; num < chunkNumber; num++) {\n      this.chunks[num].markComplete();\n    }\n  }\n}\n","// INTERNAL HELPER METHODS (handy, but ultimately not part of uploading)\nimport {ExtendedFile} from \"./types/types\";\n\nexport default class ResumableHelpers {\n  /**\n   * Stop the propagation and default behavior of the given event `e`.\n   */\n  static stopEvent(e: Event): void {\n    e.stopPropagation();\n    e.preventDefault();\n  }\n\n  /**\n   * Generate a unique identifier for the given file based on its size, filename and relative path.\n   * @param {ExtendedFile} file The file for which the identifier should be generated\n   * @returns {string} The unique identifier for the given file object\n   */\n  static generateUniqueIdentifier(file: ExtendedFile): string {\n    let relativePath = file.webkitRelativePath || file.relativePath || file.name;\n    // The '/' is used to display the relative path of the file. This information should be preserved\n    relativePath = relativePath.replace('/', '-');\n    // Remove special characters\n    return (file.size + '-' + relativePath.replace(/[^0-9a-zA-Z_-]/img, ''));\n  }\n\n  /**\n   * Flatten the given array and all contained subarrays.\n   * Credit: {@link https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore#_flattendeep}\n   */\n  static flattenDeep(array: any[]): any[] {\n    return Array.isArray(array)\n      ? array.reduce((a, b) => a.concat(this.flattenDeep(b)), [])\n      : [array];\n  }\n\n  /**\n   * Filter the given array based on the predicate inside `callback`\n   * and executes `errorCallback` for duplicate elements.\n   */\n  static uniqBy(array: any[], callback: Function, errorCallback: Function): any[] {\n    let seen = new Set();\n    return array.filter((item) => {\n      let k = callback(item);\n      if (seen.has(k)) {\n        errorCallback(item);\n        return false;\n      } else {\n        seen.add(k);\n        return true;\n      }\n    });\n  }\n\n  /**\n   * Format the size given in Bytes in a human readable format.\n   */\n  static formatSize(size: number): string {\n    if (size < 1024) {\n      return size + ' bytes';\n    }\n    if (size < 1024 * 1024) {\n      return (size / 1024.0).toFixed(0) + ' KB';\n    }\n    if (size < 1024 * 1024 * 1024) {\n      return (size / 1024.0 / 1024.0).toFixed(1) + ' MB';\n    }\n    return (size / 1024.0 / 1024.0 / 1024.0).toFixed(1) + ' GB';\n  }\n\n  /**\n   * Get the target url for the specified request type and params\n   */\n  static getTarget(\n    requestType: string,\n    sendTarget: string,\n    testTarget: string,\n    params: object,\n    parameterNamespace: string = ''\n  ) {\n    let target = sendTarget;\n\n    if (requestType === 'test' && testTarget) {\n      target = testTarget === '/' ? sendTarget : testTarget;\n    }\n\n    let separator = target.indexOf('?') < 0 ? '?' : '&';\n    let joinedParams = Object.entries(params).map(([key, value]) => [\n      encodeURIComponent(parameterNamespace + key),\n      encodeURIComponent(value),\n    ].join('=')).join('&');\n\n    if (joinedParams) target = target + separator + joinedParams;\n\n    return target;\n  }\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(603);\n"],"names":["root","factory","exports","module","define","amd","this","Resumable","constructor","options","super","files","validators","clearInput","dragOverClass","fileTypes","fileTypeErrorCallback","file","alert","fileName","name","_generateUniqueIdentifier","maxFileSizeErrorCallback","formatSize","maxFileSize","maxFilesErrorCallback","maxFiles","minFileSize","minFileSizeErrorCallback","prioritizeFirstAndLastChunk","fileValidationErrorCallback","simultaneousUploads","setInstanceProperties","opts","checkSupport","support","undefined","File","Blob","FileList","prototype","slice","Error","Object","assign","sanitizeFileTypes","map","type","replace","toLowerCase","mapDirectoryItemToFile","item","path","isFile","Promise","resolve","reject","relativePath","isDirectory","processDirectory","console","warn","mapDragItemToFile","entry","webkitGetAsEntry","getAsFile","directory","dirReader","createReader","allEntries","readEntries","entries","length","concat","all","removeDragOverClassAndCallOnDrop","e","currentTarget","classList","remove","onDrop","stopEvent","items","dataTransfer","fire","promises","flattenDeep","appendFilesFromFileList","onDragLeave","onDragOverEnter","preventDefault","dt","types","includes","stopPropagation","dropEffect","effectAllowed","add","validateFiles","validationPromises","uniqBy","uniqueIdentifier","some","addedFile","fileType","fileExtension","split","pop","substring","indexOf","size","results","filter","_v","index","fileList","event","removeFile","filesWithUniqueIdentifiers","generateUniqueIdentifier","validatedFiles","skippedFiles","f","on","handleChunkSuccess","handleChunkError","handleChunkCancel","args","handleFileProgress","handleFileError","handleFileSuccess","handleFileCancel","handleFileRetry","push","uploadNextChunk","chunks","status","send","upload","assignBrowse","domNodes","HTMLElement","domNode","input","HTMLInputElement","document","createElement","setAttribute","style","display","addEventListener","opacity","focus","click","appendChild","removeAttribute","setFileTypes","handleChangeEvent","bind","assignDrop","unAssignDrop","removeEventListener","match","join","isUploading","num","pause","abort","cancel","i","progress","totalDone","reduce","accumulator","totalSize","getSize","addFile","addFiles","addFileValidator","validator","splice","getFromUniqueIdentifier","find","handleDropEvent","eventTarget","target","value","checkUploadComplete","every","isComplete","ResumableChunk","fileObj","offset","lastProgressCallback","Date","tested","retries","pendingRetry","isMarkedComplete","loaded","xhr","chunkSize","fileParameterName","chunkNumberParameterName","chunkSizeParameterName","currentChunkSizeParameterName","totalSizeParameterName","typeParameterName","identifierParameterName","fileNameParameterName","relativePathParameterName","totalChunksParameterName","throttleProgressCallbacks","query","headers","method","uploadMethod","testMethod","parameterNamespace","testChunks","maxChunkRetries","chunkRetryInterval","permanentErrors","withCredentials","xhrTimeout","chunkFormat","setChunkTypeFromFile","testTarget","fileObjSize","fileObjType","startByte","endByte","Math","min","setCustomHeaders","customHeaders","Function","header","hasOwnProperty","setRequestHeader","formattedQuery","customQuery","extraData","readyState","getTarget","requestType","test","XMLHttpRequest","testHandler","message","open","timeout","now","getTime","doneHandler","retryInterval","setTimeout","bytes","data","FormData","queryKey","append","fr","FileReader","onload","result","readAsDataURL","responseText","relative","factor","markComplete","registeredEventHandlers","callback","executeEventCallback","forEach","ResumableFile","_prevProgress","isPaused","webkitRelativePath","_error","bootstrap","abortCount","chunk","retry","firedRetry","progressHandler","retryHandler","successHandler","errorHandler","maxOffset","max","ceil","ret","error","markChunksCompleted","chunkNumber","static","array","Array","isArray","a","b","errorCallback","seen","Set","k","has","toFixed","sendTarget","params","separator","joinedParams","key","encodeURIComponent","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","call"],"sourceRoot":""}