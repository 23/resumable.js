{"version":3,"file":"main.js","mappings":"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","sources":["webpack://resumablejs/webpack/universalModuleDefinition","webpack://resumablejs/./src/resumableChunk.ts","webpack://resumablejs/./src/resumableEventHandler.ts","webpack://resumablejs/./src/resumableFile.ts","webpack://resumablejs/./src/resumableHelpers.ts","webpack://resumablejs/webpack/bootstrap","webpack://resumablejs/./src/resumable.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"resumablejs\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"resumablejs\"] = factory();\n\telse\n\t\troot[\"resumablejs\"] = factory();\n})(this, function() {\nreturn ","import Helpers from './resumableHelpers';\r\nimport ResumableEventHandler from './resumableEventHandler';\r\nimport ResumableFile from './resumableFile';\r\nimport {ResumableChunkStatus, ResumableConfiguration} from './types/types';\r\n\r\n/**\r\n * A file chunk that contains all the data that for a single upload request\r\n */\r\nexport default class ResumableChunk extends ResumableEventHandler {\r\n  private fileObj: ResumableFile;\r\n  private fileObjSize: number;\r\n  private fileObjType: string;\r\n  private offset: number;\r\n  private lastProgressCallback: Date = new Date;\r\n  private tested: boolean = false;\r\n  private retries: number = 0;\r\n  private pendingRetry: boolean = false;\r\n  private isMarkedComplete: boolean = false;\r\n  private loaded: number = 0;\r\n  private startByte: number;\r\n  private endByte: number;\r\n  private xhr: XMLHttpRequest = null;\r\n\r\n  // Option properties\r\n  private chunkSize: number = 1024 * 1024; // 1 MB\r\n  private forceChunkSize: boolean = false;\r\n  private fileParameterName: string = 'file';\r\n  chunkNumberParameterName: string = 'resumableChunkNumber';\r\n  chunkSizeParameterName: string = 'resumableChunkSize';\r\n  currentChunkSizeParameterName: string = 'resumableCurrentChunkSize';\r\n  totalSizeParameterName: string = 'resumableTotalSize';\r\n  typeParameterName: string = 'resumableType';\r\n  identifierParameterName: string = 'resumableIdentifier';\r\n  fileNameParameterName: string = 'resumableFilename';\r\n  relativePathParameterName: string = 'resumableRelativePath';\r\n  totalChunksParameterName: string = 'resumableTotalChunks';\r\n  throttleProgressCallbacks: number = 0.5;\r\n  query: object = {};\r\n  headers: object = {};\r\n  method: string = 'multipart';\r\n  uploadMethod: string = 'POST';\r\n  testMethod: string = 'GET';\r\n  parameterNamespace: string = '';\r\n  testChunks: boolean = true;\r\n  maxChunkRetries: number = 100;\r\n  chunkRetryInterval?: number = undefined;\r\n  permanentErrors: number[] = [400, 401, 403, 404, 409, 415, 500, 501];\r\n  withCredentials: boolean = false;\r\n  xhrTimeout: number = 0;\r\n  chunkFormat: string = 'blob';\r\n  setChunkTypeFromFile: boolean = false;\r\n  target: string = '/';\r\n  testTarget: string = '';\r\n\r\n\r\n  constructor(fileObj: ResumableFile, offset: number, options: ResumableConfiguration) {\r\n    super();\r\n    this.setInstanceProperties(options);\r\n    this.fileObj = fileObj;\r\n    this.fileObjSize = fileObj.size;\r\n    this.fileObjType = fileObj.file.type;\r\n    this.offset = offset;\r\n\r\n    // Computed properties\r\n    this.startByte = this.offset * this.chunkSize;\r\n    this.endByte = Math.min(this.fileObjSize, (this.offset + 1) * this.chunkSize);\r\n    if (this.fileObjSize - this.endByte < this.chunkSize && !this.forceChunkSize) {\r\n      // The last chunk will be bigger than the chunk size, but less than 2*chunkSize\r\n      this.endByte = this.fileObjSize;\r\n    }\r\n    this.xhr = null;\r\n  }\r\n\r\n  /**\r\n   * Set the options provided inside the configuration object on this instance\r\n   */\r\n  setInstanceProperties(options: ResumableConfiguration): void {\r\n    Object.assign(this, options);\r\n  }\r\n\r\n  /**\r\n   * Set the header values for the current XMLHttpRequest\r\n   */\r\n  setCustomHeaders(): void {\r\n    if (!this.xhr) {\r\n      return;\r\n    }\r\n    let customHeaders = this.headers;\r\n    if (customHeaders instanceof Function) {\r\n      customHeaders = customHeaders(this.fileObj, this);\r\n    }\r\n    for (const header in customHeaders) {\r\n      if (!customHeaders.hasOwnProperty(header)) continue;\r\n      this.xhr.setRequestHeader(header, customHeaders[header]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get query parameters for this chunk as an object, combined with custom parameters if provided\r\n   */\r\n  get formattedQuery(): object {\r\n    var customQuery = this.query;\r\n    if (typeof customQuery == 'function') customQuery = customQuery(this.fileObj, this);\r\n\r\n    // Add extra data to identify chunk\r\n    const extraData = {\r\n      // define key/value pairs for additional parameters\r\n      [this.chunkNumberParameterName]: this.offset + 1,\r\n      [this.chunkSizeParameterName]: this.chunkSize,\r\n      [this.currentChunkSizeParameterName]: this.endByte - this.startByte,\r\n      [this.totalSizeParameterName]: this.fileObjSize,\r\n      [this.typeParameterName]: this.fileObjType,\r\n      [this.identifierParameterName]: this.fileObj.uniqueIdentifier,\r\n      [this.fileNameParameterName]: this.fileObj.fileName,\r\n      [this.relativePathParameterName]: this.fileObj.relativePath,\r\n      [this.totalChunksParameterName]: this.fileObj.chunks.length,\r\n    };\r\n    return {...extraData, ...customQuery};\r\n  }\r\n\r\n  /**\r\n   * Determine the status for this Chunk based on different parameters of the underlying XMLHttpRequest\r\n   */\r\n  get status(): ResumableChunkStatus {\r\n    if (this.pendingRetry) {\r\n      // if pending retry then that's effectively the same as actively uploading,\r\n      // there might just be a slight delay before the retry starts\r\n      return ResumableChunkStatus.UPLOADING;\r\n    } else if (this.isMarkedComplete) {\r\n      return ResumableChunkStatus.SUCCESS;\r\n    } else if (!this.xhr) {\r\n      return ResumableChunkStatus.PENDING;\r\n    } else if (this.xhr.readyState < 4) {\r\n      // Status is really 'OPENED', 'HEADERS_RECEIVED' or 'LOADING' - meaning that stuff is happening\r\n      return ResumableChunkStatus.UPLOADING;\r\n    } else if (this.xhr.status === 200 || this.xhr.status === 201) {\r\n      // HTTP 200, 201 (created)\r\n      return ResumableChunkStatus.SUCCESS;\r\n    } else if (this.permanentErrors.includes(this.xhr.status) || this.retries >= this.maxChunkRetries) {\r\n      // HTTP 400, 404, 409, 415, 500, 501 (permanent error)\r\n      return ResumableChunkStatus.ERROR;\r\n    } else {\r\n      // this should never happen, but we'll reset and queue a retry\r\n      // a likely case for this would be 503 service unavailable\r\n      this.abort();\r\n      return ResumableChunkStatus.PENDING;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Get the target url for the specified request type and the configured parameters of this chunk\r\n   * @param requestType The type of the request, either 'test' or 'upload'\r\n   */\r\n  getTarget(requestType: string): string {\r\n    return Helpers.getTarget(requestType, this.target, this.testTarget, this.formattedQuery, this.parameterNamespace);\r\n  }\r\n\r\n  /**\r\n   * Makes a GET request without any data to see if the chunk has already been uploaded in a previous session\r\n   */\r\n  test(): void {\r\n    // Set up request and listen for event\r\n    this.xhr = new XMLHttpRequest();\r\n\r\n    var testHandler = () => {\r\n      this.tested = true;\r\n      var status = this.status;\r\n      if (status === ResumableChunkStatus.SUCCESS) {\r\n        this.fire('chunkSuccess', this.message());\r\n      } else {\r\n        this.send();\r\n      }\r\n    };\r\n    this.xhr.addEventListener('load', testHandler, false);\r\n    this.xhr.addEventListener('error', testHandler, false);\r\n    this.xhr.addEventListener('timeout', testHandler, false);\r\n\r\n    // Append the relevant chunk and send it\r\n    this.xhr.open(this.testMethod, this.getTarget('test'));\r\n    this.xhr.timeout = this.xhrTimeout;\r\n    this.xhr.withCredentials = this.withCredentials;\r\n    // Add data from header options\r\n    this.setCustomHeaders();\r\n\r\n    this.xhr.send(null);\r\n  }\r\n\r\n  /**\r\n   * Abort and reset a request\r\n   */\r\n  abort(): void {\r\n    if (this.xhr) this.xhr.abort();\r\n    this.xhr = null;\r\n  }\r\n\r\n  /**\r\n   *  Uploads the actual data in a POST call\r\n   */\r\n  send(): void {\r\n    if (this.testChunks && !this.tested) {\r\n      this.test();\r\n      return;\r\n    }\r\n\r\n    // Set up request and listen for event\r\n    this.xhr = new XMLHttpRequest();\r\n\r\n    // Progress\r\n    this.xhr.upload.addEventListener('progress', (e: ProgressEvent<XMLHttpRequestEventTarget>) => {\r\n      if (Date.now() - this.lastProgressCallback.getTime() > this.throttleProgressCallbacks * 1000) {\r\n        this.fire('chunkProgress');\r\n        this.lastProgressCallback = new Date();\r\n      }\r\n      this.loaded = e.loaded || 0;\r\n    }, false);\r\n    this.loaded = 0;\r\n    this.pendingRetry = false;\r\n    this.fire('chunkProgress');\r\n\r\n    /**\r\n     * Handles the different xhr registeredEventHandlers based on the status of this chunk\r\n     */\r\n    let doneHandler = () => {\r\n      var status = this.status;\r\n      switch (status) {\r\n        case ResumableChunkStatus.SUCCESS:\r\n        case ResumableChunkStatus.ERROR:\r\n          this.fire(status, this.message());\r\n          break;\r\n        default:\r\n          this.fire('chunkRetry', this.message());\r\n          this.abort();\r\n          this.retries++;\r\n          let retryInterval = this.chunkRetryInterval;\r\n          if (retryInterval !== undefined) {\r\n            this.pendingRetry = true;\r\n            setTimeout(this.send, retryInterval);\r\n          } else {\r\n            this.send();\r\n          }\r\n          break;\r\n      }\r\n    };\r\n    this.xhr.addEventListener('load', doneHandler, false);\r\n    this.xhr.addEventListener('error', doneHandler, false);\r\n    this.xhr.addEventListener('timeout', doneHandler, false);\r\n\r\n    // Set up the basic query data from Resumable\r\n    let bytes = this.fileObj.file.slice(this.startByte, this.endByte,\r\n      this.setChunkTypeFromFile ? this.fileObj.file.type : '');\r\n    let data = null;\r\n    let parameterNamespace = this.parameterNamespace;\r\n    // Add data from the query options\r\n    if (this.method === 'octet') {\r\n      data = bytes;\r\n    } else {\r\n      data = new FormData();\r\n      for (const queryKey in this.formattedQuery) {\r\n        data.append(parameterNamespace + queryKey, this.formattedQuery[queryKey]);\r\n      }\r\n      switch (this.chunkFormat) {\r\n        case 'blob':\r\n          data.append(parameterNamespace + this.fileParameterName, bytes, this.fileObj.fileName);\r\n          break;\r\n        case 'base64':\r\n          var fr = new FileReader();\r\n          fr.onload = () => {\r\n            data.append(parameterNamespace + this.fileParameterName, fr.result);\r\n            this.xhr.send(data);\r\n          };\r\n          fr.readAsDataURL(bytes);\r\n          break;\r\n      }\r\n    }\r\n\r\n    let target = this.getTarget('upload');\r\n\r\n    this.xhr.open(this.uploadMethod, target);\r\n    if (this.method === 'octet') {\r\n      this.xhr.setRequestHeader('Content-Type', 'application/octet-stream');\r\n    }\r\n    this.xhr.timeout = this.xhrTimeout;\r\n    this.xhr.withCredentials = this.withCredentials;\r\n    // Add data from header options\r\n    this.setCustomHeaders();\r\n\r\n    if (this.chunkFormat === 'blob') {\r\n      this.xhr.send(data);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Return the response text of the underlying XMLHttpRequest if it exists\r\n   */\r\n  message(): string {\r\n    return this.xhr ? this.xhr.responseText : '';\r\n  };\r\n\r\n  /**\r\n   * Return the progress for the current chunk as a number between 0 and 1\r\n   * @param relative Whether or not the progress should be calculated based on the size of the entire file\r\n   */\r\n  progress(relative: boolean = false): number {\r\n    var factor = relative ? (this.endByte - this.startByte) / this.fileObjSize : 1;\r\n    if (this.pendingRetry) return 0;\r\n    if ((!this.xhr || !this.xhr.status) && !this.isMarkedComplete) factor *= .95;\r\n    switch (this.status) {\r\n      case ResumableChunkStatus.SUCCESS:\r\n      case ResumableChunkStatus.ERROR:\r\n        return factor;\r\n      case ResumableChunkStatus.PENDING:\r\n        return 0;\r\n      default:\r\n        return this.loaded / (this.endByte - this.startByte) * factor;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Mark this chunk as completed because it was already uploaded to the server.\r\n   */\r\n  markComplete(): void {\r\n    this.isMarkedComplete = true;\r\n  }\r\n}\r\n","/**\r\n * The underlying base class for ResumableJS. This class is responsible for registering and executing\r\n * events and listeners.\r\n */\r\nexport default class ResumableEventHandler {\r\n  private registeredEventHandlers: { [event: string]: Function[]};\r\n\r\n  /**\r\n   * Construct a new event handler instance.\r\n   */\r\n  constructor() {\r\n    this.registeredEventHandlers = {};\r\n  }\r\n\r\n  /**\r\n   * Register a new callback for the given event.\r\n   */\r\n  on(event: string, callback: Function): void {\r\n    event = event.toLowerCase();\r\n    if (!this.registeredEventHandlers.hasOwnProperty(event)) {\r\n      this.registeredEventHandlers[event] = [];\r\n    }\r\n    this.registeredEventHandlers[event].push(callback);\r\n  }\r\n\r\n  /**\r\n   * Fire the event listeners for the given event with the given arguments as well as the wildcard event '*'\r\n   */\r\n  fire(event: string, ...args): void {\r\n    event = event.toLowerCase();\r\n\r\n    this.executeEventCallback(event, ...args);\r\n    this.executeEventCallback('*', event, ...args);\r\n  }\r\n\r\n  /**\r\n   * Execute all callbacks for the given event with the provided arguments. This function is only used internally\r\n   * to call all callbacks registered to a given event individually.\r\n   */\r\n  private executeEventCallback(event: string, ...args): void {\r\n    if (!this.registeredEventHandlers.hasOwnProperty(event)) return;\r\n    this.registeredEventHandlers[event].forEach((callback) => callback(...args));\r\n  }\r\n}\r\n","import ResumableChunk from './resumableChunk';\r\nimport Helpers from './resumableHelpers';\r\nimport ResumableEventHandler from './resumableEventHandler';\r\nimport {ResumableChunkStatus, ResumableConfiguration} from './types/types';\r\n\r\n/**\r\n * A single file object that should be uploaded in multiple chunks\r\n */\r\nexport default class ResumableFile extends ResumableEventHandler {\r\n  private opts: ResumableConfiguration;\r\n  private _prevProgress: number = 0;\r\n  private isPaused: boolean = false;\r\n\r\n  file: File;\r\n  fileName: string;\r\n  size: number;\r\n  relativePath: string;\r\n  uniqueIdentifier: string;\r\n  private _error: boolean;\r\n  chunks: ResumableChunk[] = [];\r\n  private chunkSize: number = 1024 * 1024; // 1 MB\r\n  private forceChunkSize: boolean = false;\r\n\r\n  constructor(file: File, uniqueIdentifier: string, options: object) {\r\n    super();\r\n    this.opts = options;\r\n    this.setInstanceProperties(options);\r\n    this.file = file;\r\n    this.fileName = Helpers.getFileNameFromFile(file);\r\n    this.size = file.size;\r\n    this.relativePath = /*file.relativePath ||*/ file.webkitRelativePath || this.fileName;\r\n    this.uniqueIdentifier = uniqueIdentifier;\r\n    this._error = uniqueIdentifier !== undefined;\r\n\r\n    // Bootstrap file\r\n    this.fire('chunkingStart', this);\r\n    this.bootstrap();\r\n  }\r\n\r\n  /**\r\n   * Set the options provided inside the configuration object on this instance\r\n   */\r\n  setInstanceProperties(options: ResumableConfiguration) {\r\n    Object.assign(this, options);\r\n  }\r\n\r\n  /**\r\n   * Stop current uploads for this file\r\n   */\r\n  abort(): void {\r\n    let abortCount = 0;\r\n    for (const chunk of this.chunks) {\r\n      if (chunk.status === ResumableChunkStatus.UPLOADING) {\r\n        chunk.abort();\r\n        abortCount++;\r\n      }\r\n    }\r\n    if (abortCount > 0) this.fire('fileProgress', this);\r\n  }\r\n\r\n  /**\r\n   * Cancel uploading this file and remove it from the file list\r\n   */\r\n  cancel(): void {\r\n    for (const chunk of this.chunks) {\r\n      if (chunk.status === ResumableChunkStatus.UPLOADING) {\r\n        chunk.abort();\r\n        this.fire('chunkCancel', chunk);\r\n      }\r\n    }\r\n    // Reset this file to be void\r\n    this.chunks = [];\r\n    this.fire('fileCancel', this);\r\n    this.fire('fileProgress', this);\r\n  }\r\n\r\n  /**\r\n   * Retry uploading this file\r\n   */\r\n  retry(): void {\r\n    this.bootstrap();\r\n    let firedRetry = false;\r\n    this.on('chunkingComplete', () => {\r\n      if (!firedRetry) this.fire('fileRetry');\r\n      firedRetry = true;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Prepare this file for a new upload, by dividing it into multiple chunks\r\n   */\r\n  bootstrap(): void {\r\n    const progressHandler = (message) => this.fire('fileProgress', this, message);\r\n    const retryHandler = () =>  this.fire('fileRetry', this);\r\n    const successHandler = (message) => {\r\n      if (this._error) return;\r\n      this.fire('chunkSuccess');\r\n      this.fire('fileProgress', this, message); // it's at least progress\r\n      if (this.isComplete) {\r\n        this.fire('fileSuccess', this, message);\r\n      }\r\n    };\r\n    const errorHandler = (message) => {\r\n      this.fire('chunkError', message);\r\n      this.abort();\r\n      this._error = true;\r\n      this.chunks = [];\r\n      this.fire('fileError', this, message);\r\n    }\r\n\r\n    this.abort();\r\n    this._error = false;\r\n    // Rebuild stack of chunks from file\r\n    this.chunks = [];\r\n    this._prevProgress = 0;\r\n    const round = this.forceChunkSize ? Math.ceil : Math.floor;\r\n    const maxOffset = Math.max(round(this.file.size / this.chunkSize), 1);\r\n    for (var offset = 0; offset < maxOffset; offset++) {\r\n      const chunk = new ResumableChunk(this, offset, this.opts);\r\n      chunk.on('chunkProgress', progressHandler);\r\n      chunk.on('chunkError', errorHandler);\r\n      chunk.on('chunkSuccess', successHandler);\r\n      chunk.on('chunkRetry', retryHandler);\r\n      this.chunks.push(chunk);\r\n      this.fire('chunkingProgress', this, offset / maxOffset);\r\n    }\r\n    this.fire('chunkingComplete', this);\r\n  }\r\n\r\n  /**\r\n   * Get the progress for uploading this file based on the progress of the individual file chunks\r\n   */\r\n  progress(): number {\r\n    if (this._error) return 1;\r\n    // Sum up progress across everything\r\n    var ret = 0;\r\n    var error = false;\r\n    for (const chunk of this.chunks) {\r\n      if (chunk.status === ResumableChunkStatus.ERROR) error = true;\r\n      ret += chunk.progress(true); // get chunk progress relative to entire file\r\n    }\r\n    ret = error ? 1 : (ret > 0.99999 ? 1 : ret);\r\n    ret = Math.max(this._prevProgress, ret); // We don't want to lose percentages when an upload is paused\r\n    this._prevProgress = ret;\r\n    return ret;\r\n  }\r\n\r\n  /**\r\n   * Check whether at least one of this file's chunks is currently uploading\r\n   */\r\n  get isUploading(): boolean {\r\n    return this.chunks.some((chunk) => chunk.status === ResumableChunkStatus.UPLOADING);\r\n  }\r\n\r\n  /**\r\n   * Check whether all of this file's chunks completed their upload requests and whether it should be\r\n   * treated as completed.\r\n   */\r\n  get isComplete(): boolean {\r\n    return !this.chunks.some((chunk) =>\r\n      chunk.status === ResumableChunkStatus.PENDING || chunk.status === ResumableChunkStatus.UPLOADING);\r\n  }\r\n\r\n  /**\r\n   * Initiate the upload of a new chunk for this file. This function returns whether a new upload was started or not.\r\n   */\r\n  upload(): boolean {\r\n    if (this.isPaused) {\r\n      return false;\r\n    }\r\n\r\n    for (const chunk of this.chunks) {\r\n      if (chunk.status === ResumableChunkStatus.PENDING) {\r\n        chunk.send();\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Mark a given number of chunks as already uploaded to the server.\r\n   * @param chunkNumber The index until which all chunks should be marked as completed\r\n   */\r\n  markChunksCompleted(chunkNumber: number): void {\r\n    if (!this.chunks || this.chunks.length <= chunkNumber) {\r\n      return;\r\n    }\r\n    for (let num = 0; num < chunkNumber; num++) {\r\n      this.chunks[num].markComplete();\r\n    }\r\n  }\r\n}\r\n","// INTERNAL HELPER METHODS (handy, but ultimately not part of uploading)\r\nexport default class ResumableHelpers {\r\n  /**\r\n   * Stop the propagation and default behavior of the given event `e`.\r\n   */\r\n  static stopEvent(e: Event): void {\r\n    e.stopPropagation();\r\n    e.preventDefault();\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param file The file whose filename should be retrieved\r\n   */\r\n  static getFileNameFromFile(file: File): string {\r\n    return /*file.fileName ||*/ file.name;\r\n  }\r\n\r\n  /**\r\n   * Generate a unique identifier for the given file based on its size, filename and relative path.\r\n   * @param {File} file The file for which the identifier should be generated\r\n   * @returns {string} The unique identifier for the given file object\r\n   */\r\n  static generateUniqueIdentifier(file: File): string {\r\n    var relativePath = file.webkitRelativePath || /*file.relativePath ||*/ this.getFileNameFromFile(file);\r\n    var size = file.size;\r\n    return (size + '-' + relativePath.replace(/[^0-9a-zA-Z_-]/img, ''));\r\n  }\r\n\r\n  /**\r\n   * Flatten the given array and all contained subarrays.\r\n   * Credit: {@link https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore#_flattendeep}\r\n   */\r\n  static flattenDeep(array: any[]): any[] {\r\n    return Array.isArray(array)\r\n      ? array.reduce((a, b) => a.concat(this.flattenDeep(b)), [])\r\n      : [array];\r\n  }\r\n\r\n  /**\r\n   * Filter the given array based on the predicate inside `callback`\r\n   * and executes `errorCallback` for duplicate elements.\r\n   */\r\n  static uniqBy(array: any[], callback: Function, errorCallback: Function): any[] {\r\n    let seen = new Set();\r\n    return array.filter((item) => {\r\n      let k = callback(item);\r\n      if (seen.has(k)) {\r\n        errorCallback(item);\r\n        return false;\r\n      } else {\r\n        seen.add(k);\r\n        return true;\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Format the size given in Bytes in a human readable format.\r\n   */\r\n  static formatSize(size: number): string {\r\n    if (size < 1024) {\r\n      return size + ' bytes';\r\n    }\r\n    if (size < 1024 * 1024) {\r\n      return (size / 1024.0).toFixed(0) + ' KB';\r\n    }\r\n    if (size < 1024 * 1024 * 1024) {\r\n      return (size / 1024.0 / 1024.0).toFixed(1) + ' MB';\r\n    }\r\n    return (size / 1024.0 / 1024.0 / 1024.0).toFixed(1) + ' GB';\r\n  }\r\n\r\n  /**\r\n   * Get the target url for the specified request type and params\r\n   */\r\n  static getTarget(\r\n    requestType: string,\r\n    sendTarget: string,\r\n    testTarget: string,\r\n    params: object,\r\n    parameterNamespace: string = ''\r\n  ) {\r\n    let target = sendTarget;\r\n\r\n    if (requestType === 'test' && testTarget) {\r\n      target = testTarget === '/' ? sendTarget : testTarget;\r\n    }\r\n\r\n    let separator = target.indexOf('?') < 0 ? '?' : '&';\r\n    let joinedParams = Object.entries(params).map(([key, value]) => [\r\n      encodeURIComponent(parameterNamespace + key),\r\n      encodeURIComponent(value),\r\n    ].join('=')).join('&');\r\n\r\n    if (joinedParams) target = target + separator + joinedParams;\r\n\r\n    return target;\r\n  }\r\n}\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","import Helpers from './resumableHelpers';\r\nimport ResumableFile from './resumableFile';\r\nimport ResumableEventHandler from './resumableEventHandler';\r\nimport {ExtendedFile, ResumableChunkStatus, ResumableConfiguration} from './types/types';\r\n\r\n/*\r\n* MIT Licensed\r\n* http://www.twentythree.com/\r\n* http://github.com/23/resumable.js\r\n* Steffen Tiedemann Christensen, steffen@twentythree.com\r\n*/\r\n\r\n/**\r\n * An instance of a resumable upload handler that contains one or multiple files which should be uploaded in chunks.\r\n */\r\nexport class Resumable extends ResumableEventHandler {\r\n  private opts: ResumableConfiguration;\r\n  private files: ResumableFile[] = [];\r\n  private validators: {[fileType: string]: Function} = {};\r\n  private support: boolean;\r\n\r\n  // Configuration Options\r\n  clearInput: boolean = true;\r\n  dragOverClass: string = 'dragover';\r\n  fileTypes: string[] = [];\r\n  fileTypeErrorCallback: Function = (file) => {\r\n    alert(`${file.fileName || file.name} has an unsupported file type, please upload files of type ${this.fileTypes}.`);\r\n  };\r\n  _generateUniqueIdentifier: Function = null;\r\n  maxFileSize?: number;\r\n  maxFileSizeErrorCallback: Function = (file) => {\r\n    alert(file.fileName || file.name + ' is too large, please upload files less than ' +\r\n      Helpers.formatSize(this.maxFileSize) + '.');\r\n  };\r\n  maxFiles?: number;\r\n  maxFilesErrorCallback: Function = (files) => {\r\n    var maxFiles = this.maxFiles;\r\n    alert('Please upload no more than ' + maxFiles + ' file' + (maxFiles === 1 ? '' : 's') + ' at a time.');\r\n  };\r\n  minFileSize: number = 1;\r\n  minFileSizeErrorCallback: Function = (file) => {\r\n    alert(file.fileName || file.name + ' is too small, please upload files larger than ' +\r\n      Helpers.formatSize(this.minFileSize) + '.');\r\n  };\r\n  prioritizeFirstAndLastChunk: boolean = false;\r\n  fileValidationErrorCallback: Function = (file) => {};\r\n  simultaneousUploads: number = 3;\r\n\r\n  constructor(options: ResumableConfiguration) {\r\n    super();\r\n    this.setInstanceProperties(options);\r\n    this.opts = options;\r\n    this.checkSupport();\r\n  }\r\n\r\n  /**\r\n   * Check whether the current browser supports the essential functions for the package to work.\r\n   * The method checks if these features are supported:\r\n   * - File object type\r\n   * - Blob object type\r\n   * - FileList object type\r\n   * - slicing files\r\n   */\r\n  private checkSupport(): void {\r\n    this.support =\r\n      File !== undefined &&\r\n      Blob !== undefined &&\r\n      FileList !== undefined &&\r\n      !!Blob.prototype.slice;\r\n    if (!this.support) {\r\n      throw new Error('Not supported by Browser');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Assign the attributes of this instance via destructuring of the options object.\r\n   */\r\n  private setInstanceProperties(options: ResumableConfiguration) {\r\n    Object.assign(this, options);\r\n\r\n    // For good behaviour we do some initial sanitizing. Remove spaces and dots and lowercase all\r\n    this.fileTypes = this.fileTypes.map((type) => type.replace(/[\\s.]/g, '').toLowerCase());\r\n  }\r\n\r\n  /**\r\n   * Transforms a single fileEntry or DirectoryEntry item into a list of File objects\r\n   * @param {Object} item item to upload, may be file or directory entry\r\n   * @param {string} path current file path\r\n   */\r\n  private async mapItemToFile(item: FileSystemEntry, path: string): Promise<File[]> {\r\n    if (item instanceof FileSystemFileEntry) {\r\n      // file entry provided\r\n      const file = await new Promise((resolve, reject) => item.file(resolve, reject)) as ExtendedFile;\r\n      file.relativePath = path + file.name;\r\n      return [file];\r\n    } else if (item instanceof FileSystemDirectoryEntry) {\r\n      return await this.processDirectory(item, path + item.name + '/');\r\n    } else if (item instanceof File) {\r\n      return [item];\r\n    }\r\n\r\n    console.warn('Item mapping did not return a file object. This might be due to an unknown file type.')\r\n    return [];\r\n  }\r\n\r\n  /**\r\n   * Transforms a single DataTransfer item into a File object. This may include either extracting the given file or\r\n   * all files inside the provided directory.\r\n   * @param item item to upload, may be file or directory entry\r\n   * @param path current file path\r\n   */\r\n  private async mapDragItemToFile(item: DataTransferItem, path: string): Promise<File[]> {\r\n    let entry = item.webkitGetAsEntry();\r\n    if (entry instanceof FileSystemDirectoryEntry) {\r\n      return await this.processDirectory(entry, path + entry.name + '/');\r\n    }\r\n\r\n    let file = item.getAsFile();\r\n    if (file instanceof File) {\r\n      (file as ExtendedFile).relativePath = path + file.name;\r\n      return [file];\r\n    }\r\n\r\n    console.warn('Item mapping did not return a file object. This might be due to an unknown file type.')\r\n    return [];\r\n  }\r\n\r\n  /**\r\n   * Recursively traverse a directory and collect files to upload\r\n   */\r\n  private processDirectory(directory: FileSystemDirectoryEntry, path: string): Promise<File[]> {\r\n    return new Promise((resolve, reject) => {\r\n      const dirReader = directory.createReader();\r\n      let allEntries = [];\r\n\r\n      const readEntries = (): void => {\r\n        dirReader.readEntries(async (entries: FileSystemEntry[]): Promise<void> => {\r\n          // Read the files batch-wise (in chrome e.g. 100 at a time)\r\n          if (entries.length) {\r\n            allEntries = allEntries.concat(entries);\r\n            return readEntries();\r\n          }\r\n\r\n          // After collecting all files, map all fileEntries to File objects\r\n          allEntries = allEntries.map((entry) => {\r\n            return this.mapItemToFile(entry, path);\r\n          });\r\n          // Wait until all files are collected.\r\n          resolve(await Promise.all(allEntries));\r\n        }, reject);\r\n      };\r\n\r\n      readEntries();\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Handle the event when a new file was provided via drag-and-drop\r\n   */\r\n  private async onDrop(e: DragEvent): Promise<void> {\r\n    (e.currentTarget as HTMLElement).classList.remove(this.dragOverClass);\r\n    Helpers.stopEvent(e);\r\n\r\n    let items = [];\r\n\r\n    //handle dropped things as items if we can (this lets us deal with folders nicer in some cases)\r\n    if (e.dataTransfer && e.dataTransfer.items) {\r\n      items = Array.from(e.dataTransfer.items);\r\n    }\r\n    //else handle them as files\r\n    else if (e.dataTransfer && e.dataTransfer.files) {\r\n      items = Array.from(e.dataTransfer.files);\r\n    }\r\n\r\n    if (!items.length) {\r\n      return; // nothing to do\r\n    }\r\n    this.fire('fileProcessingBegin', items);\r\n    let promises = items.map((item) => this.mapDragItemToFile(item, ''));\r\n    let files = Helpers.flattenDeep(await Promise.all(promises));\r\n    if (files.length) {\r\n      // at least one file found\r\n      this.appendFilesFromFileList(files, e);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle the event when a drag-and-drop item leaves the area of assigned drag-and-drop area\r\n   */\r\n  private onDragLeave(e: DragEvent): void {\r\n    (e.currentTarget as HTMLElement).classList.remove(this.dragOverClass);\r\n  }\r\n\r\n  /**\r\n   * Handle the event when a drag-and-drop item enters the area of assigned drag-and-drop area\r\n   */\r\n  private onDragOverEnter(e: DragEvent): void {\r\n    e.preventDefault();\r\n    let dt = e.dataTransfer;\r\n    if (dt.types.includes('Files')) { // only for file drop\r\n      e.stopPropagation();\r\n      dt.dropEffect = 'copy';\r\n      dt.effectAllowed = 'copy';\r\n      (e.currentTarget as HTMLElement).classList.add(this.dragOverClass);\r\n    } else { // not work on IE/Edge....\r\n      dt.dropEffect = 'none';\r\n      dt.effectAllowed = 'none';\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Validate and clean a list of files. This includes the removal of duplicates, a check whether the file type is\r\n   * allowed and custom validation functions defined per file type.\r\n   * @param {ExtendedFile[]} files A list of File instances that were previously extended with a uniqueIdentifier\r\n   */\r\n  private async validateFiles(files: ExtendedFile[]): Promise<ExtendedFile[]> {\r\n    // Remove files that are duplicated in the original array, based on their unique identifiers\r\n    let uniqueFiles = Helpers.uniqBy(files,\r\n      (file) => file.uniqueIdentifier,\r\n      (file) => this.fire('fileProcessingFailed', file, 'duplicate'),\r\n    );\r\n\r\n    let validationPromises = uniqueFiles.map(async (file) => {\r\n      // Remove files that were already added based on their unique identifiers\r\n      if (this.files.some((addedFile) => addedFile.uniqueIdentifier === file.uniqueIdentifier)) {\r\n        this.fire('fileProcessingFailed', file, 'duplicate');\r\n        return false;\r\n      }\r\n\r\n      let fileType: string = file.type.toLowerCase();\r\n      let fileExtension = file.name.split('.').pop().toLowerCase();\r\n\r\n      if (this.fileTypes.length > 0) {\r\n        const fileTypeFound = this.fileTypes.some((type) => {\r\n          // Check whether the extension inside the filename is an allowed file type\r\n          return fileExtension === type ||\r\n            // If MIME type, check for wildcard or if extension matches the file's tile type\r\n            type.includes('/') && (\r\n              type.includes('*') &&\r\n              fileType.substring(0, type.indexOf('*')) === type.substring(0, type.indexOf('*')) ||\r\n              fileType === type\r\n            );\r\n        });\r\n        if (!fileTypeFound) {\r\n          this.fire('fileProcessingFailed', file, 'fileType');\r\n          this.fileTypeErrorCallback(file);\r\n          return false;\r\n        }\r\n      }\r\n\r\n      // Validate the file size against minimum and maximum allowed sizes\r\n      if (this.minFileSize !== undefined && file.size < this.minFileSize) {\r\n        this.fire('fileProcessingFailed', file, 'minFileSize');\r\n        this.minFileSizeErrorCallback(file);\r\n        return false;\r\n      }\r\n      if (this.maxFileSize !== undefined && file.size > this.maxFileSize) {\r\n        this.fire('fileProcessingFailed', file, 'maxFileSize');\r\n        this.maxFileSizeErrorCallback(file);\r\n        return false;\r\n      }\r\n\r\n      // Apply a custom validator based on the file extension\r\n      if (fileExtension in this.validators && !await this.validators[fileExtension](file)) {\r\n        this.fire('fileProcessingFailed', file, 'validation');\r\n        this.fileValidationErrorCallback(file);\r\n        return false;\r\n      }\r\n\r\n      return true;\r\n    });\r\n\r\n    const results = await Promise.all(validationPromises);\r\n\r\n    // Only include files that passed their validation tests\r\n    return files.filter((_v, index) => results[index]);\r\n  }\r\n\r\n  /**\r\n   * Add an array of files to this instance's file list by creating new ResumableFiles. This includes a validation and\r\n   * deduplication of the provided array.\r\n   * @param fileList An array containing File objects\r\n   * @param event The event with which the fileList was provided\r\n   */\r\n  private async appendFilesFromFileList(fileList: File[], event: Event): Promise<boolean> {\r\n    // check for uploading too many files\r\n    if (this.maxFiles !== undefined && this.maxFiles < fileList.length + this.files.length) {\r\n      // if single-file upload, file is already added, and trying to add 1 new file, simply replace the already-added file\r\n      if (this.maxFiles === 1 && this.files.length === 1 && fileList.length === 1) {\r\n        this.removeFile(this.files[0]);\r\n      } else {\r\n        this.fire('fileProcessingFailed', undefined, 'maxFiles');\r\n        this.maxFilesErrorCallback(fileList);\r\n        return false;\r\n      }\r\n    }\r\n\r\n    // Add the unique identifier for every new file.\r\n    // Since this might return a promise, we have to wait until it completed.\r\n    const filesWithUniqueIdentifiers = await Promise.all(fileList.map(async (file: ExtendedFile): Promise<ExtendedFile> => {\r\n      file.uniqueIdentifier = await this.generateUniqueIdentifier(file, event);\r\n      return file;\r\n    }));\r\n\r\n    // Validate the files and remove duplicates\r\n    const validatedFiles = await this.validateFiles(filesWithUniqueIdentifiers);\r\n\r\n    let skippedFiles = filesWithUniqueIdentifiers.filter((file) => !validatedFiles.includes(file));\r\n\r\n    for (const file of validatedFiles) {\r\n      let f = new ResumableFile(file, file.uniqueIdentifier, this.opts);\r\n      f.on('chunkSuccess', () => this.handleChunkSuccess());\r\n      f.on('chunkError', () => this.handleChunkError());\r\n      f.on('chunkCancel', () => this.handleChunkCancel());\r\n      f.on('fileProgress', () => this.handleFileProgress());\r\n      f.on('fileError', (...args) => this.handleFileError(args));\r\n      f.on('fileSuccess', (...args) => this.handleFileSuccess(args));\r\n      f.on('fileCancel', (...args) => this.handleFileCancel(args));\r\n      f.on('fileRetry', () => this.handleFileRetry());\r\n      this.files.push(f);\r\n      this.fire('fileAdded', f, event);\r\n    }\r\n\r\n    // all files processed, trigger event\r\n    if (!validatedFiles.length && !skippedFiles.length) {\r\n      // no succeeded files, just skip\r\n      return;\r\n    }\r\n    this.fire('filesAdded', validatedFiles, skippedFiles);\r\n  }\r\n\r\n  /**\r\n   * Generate a new unique identifier for a given file either with a default helper function or with a custom\r\n   * generator function.\r\n   * @param file The file as an HTML 5 File object\r\n   * @param event The event with which the file was provided originally\r\n   */\r\n  private generateUniqueIdentifier(file: File, event: Event): string {\r\n    return typeof this._generateUniqueIdentifier === 'function' ?\r\n      this._generateUniqueIdentifier(file, event) : Helpers.generateUniqueIdentifier(file);\r\n  }\r\n\r\n  /**\r\n   * Queue a new chunk to be uploaded that is currently awaiting upload.\r\n   */\r\n  private uploadNextChunk(): void {\r\n    // In some cases (such as videos) it's really handy to upload the first\r\n    // and last chunk of a file quickly; this lets the server check the file's\r\n    // metadata and determine if there's even a point in continuing.\r\n    if (this.prioritizeFirstAndLastChunk) {\r\n      for (const file of this.files) {\r\n        if (file.chunks.length && file.chunks[0].status === ResumableChunkStatus.PENDING) {\r\n          file.chunks[0].send();\r\n          return;\r\n        }\r\n        if (file.chunks.length > 1 && file.chunks[file.chunks.length - 1].status === ResumableChunkStatus.PENDING) {\r\n          file.chunks[file.chunks.length - 1].send();\r\n          return;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Now, simply look for the next best thing to upload\r\n    for (const file of this.files) {\r\n      if (file.upload()) return;\r\n    }\r\n  }\r\n\r\n  /**\r\n   *  PUBLIC METHODS FOR RESUMABLE.JS\r\n   *  This section only includes methods that should be callable from external packages.\r\n   */\r\n\r\n  /**\r\n   * Assign a browse action to one or more DOM nodes. Pass in true to allow directories to be selected (Chrome only).\r\n   */\r\n  assignBrowse(domNodes: HTMLInputElement | HTMLInputElement[], isDirectory: boolean = false): void {\r\n    if (domNodes instanceof HTMLInputElement) domNodes = [domNodes];\r\n    for (const domNode of domNodes) {\r\n      let input;\r\n      if (domNode.tagName === 'INPUT' && domNode.type === 'file') {\r\n        input = domNode;\r\n      } else {\r\n        input = document.createElement('input');\r\n        input.setAttribute('type', 'file');\r\n        input.style.display = 'none';\r\n        domNode.addEventListener('click', () => {\r\n          input.style.opacity = 0;\r\n          input.style.display = 'block';\r\n          input.focus();\r\n          input.click();\r\n          input.style.display = 'none';\r\n        }, false);\r\n        domNode.appendChild(input);\r\n      }\r\n      if (this.maxFiles !== 1) {\r\n        input.setAttribute('multiple', 'multiple');\r\n      } else {\r\n        input.removeAttribute('multiple');\r\n      }\r\n      if (isDirectory) {\r\n        input.setAttribute('webkitdirectory', 'webkitdirectory');\r\n      } else {\r\n        input.removeAttribute('webkitdirectory');\r\n      }\r\n      if (this.fileTypes.length >= 1) {\r\n        input.setAttribute('accept', this.fileTypes.map((type) => {\r\n          type = type.replace(/\\s/g, '').toLowerCase();\r\n          if (type.match(/^[^.][^/]+$/)) {\r\n            type = '.' + type;\r\n          }\r\n          return type;\r\n        }).join(','));\r\n      } else {\r\n        input.removeAttribute('accept');\r\n      }\r\n      // When new files are added, simply append them to the overall list\r\n      input.addEventListener('change', (e: InputEvent) => {\r\n        const eventTarget = e.target as HTMLInputElement;\r\n        this.fire('fileProcessingBegin', eventTarget.files);\r\n        this.appendFilesFromFileList(Array.from(eventTarget.files), e);\r\n        if (this.clearInput) {\r\n          eventTarget.value = '';\r\n        }\r\n      }, false);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Assign one or more DOM nodes as a drop target.\r\n   */\r\n  assignDrop(domNodes: HTMLElement | HTMLElement[]): void {\r\n    if (domNodes instanceof HTMLElement) domNodes = [domNodes];\r\n\r\n    for (const domNode of domNodes) {\r\n      domNode.addEventListener('dragover', this.onDragOverEnter.bind(this), false);\r\n      domNode.addEventListener('dragenter', this.onDragOverEnter.bind(this), false);\r\n      domNode.addEventListener('dragleave', this.onDragLeave.bind(this), false);\r\n      domNode.addEventListener('drop', this.onDrop.bind(this), false);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove one or more DOM nodes as a drop target.\r\n   */\r\n  unAssignDrop(domNodes: HTMLElement | HTMLElement[]): void {\r\n    if (domNodes instanceof HTMLElement) domNodes = [domNodes];\r\n\r\n    for (const domNode of domNodes) {\r\n      domNode.removeEventListener('dragover', this.onDragOverEnter.bind(this));\r\n      domNode.removeEventListener('dragenter', this.onDragOverEnter.bind(this));\r\n      domNode.removeEventListener('dragleave', this.onDragLeave.bind(this));\r\n      domNode.removeEventListener('drop', this.onDrop.bind(this));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check whether any files are currently uploading\r\n   */\r\n  get isUploading(): boolean {\r\n    return this.files.some((file) => file.isUploading);\r\n  }\r\n\r\n  /**\r\n   * Start or resume the upload of the provided files by initiating the upload of the first chunk\r\n   */\r\n  upload(): void {\r\n    // Make sure we don't start too many uploads at once\r\n    if (this.isUploading) return;\r\n    // Kick off the queue\r\n    this.fire('uploadStart');\r\n    for (let num = 1; num <= this.simultaneousUploads; num++) {\r\n      this.uploadNextChunk();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Pause the upload\r\n   */\r\n  pause(): void {\r\n    // Resume all chunks currently being uploaded\r\n    for (const file of this.files) {\r\n      file.abort();\r\n    }\r\n    this.fire('pause');\r\n  };\r\n\r\n  /**\r\n   * Cancel uploading and reset all files to their initial states\r\n   */\r\n  cancel(): void {\r\n    this.fire('beforeCancel');\r\n    for (let i = this.files.length - 1; i >= 0; i--) {\r\n      this.files[i].cancel();\r\n    }\r\n    this.fire('cancel');\r\n  };\r\n\r\n  /**\r\n   * Return the progress of the current upload as a float between 0 and 1\r\n   */\r\n  progress(): number {\r\n    let totalDone = this.files.reduce((accumulator, file) => accumulator + file.size * file.progress(), 0);\r\n    let totalSize = this.getSize();\r\n    return totalSize > 0 ? totalDone / totalSize : 0;\r\n  };\r\n\r\n  /**\r\n   * Add a HTML5 File object to the list of files.\r\n   */\r\n  addFile(file: File, event: Event): void {\r\n    this.appendFilesFromFileList([file], event);\r\n  };\r\n\r\n  /**\r\n   * Add a list of HTML5 File objects to the list of files.\r\n   */\r\n  addFiles(files: File[], event: Event): void {\r\n    this.appendFilesFromFileList(files, event);\r\n  };\r\n\r\n  /**\r\n   * Add a validator function for the given file type. This can e.g. be used to read the file and validate\r\n   * checksums based on certain properties.\r\n   * @param fileType The file extension for the given validator\r\n   * @param validator A callback function that should be called when validating files with the given type\r\n   */\r\n  addFileValidator(fileType: string, validator: Function): void {\r\n    if (fileType in this.validators) {\r\n      console.warn(`Overwriting validator for file type: ${fileType}`);\r\n    }\r\n    this.validators[fileType] = validator;\r\n  }\r\n\r\n  /**\r\n   * Cancel the upload of a specific ResumableFile object and remove it from the file list.\r\n   */\r\n  removeFile(file: ResumableFile): void {\r\n    for (let i = this.files.length - 1; i >= 0; i--) {\r\n      if (this.files[i] === file) {\r\n        this.files.splice(i, 1);\r\n        break;\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Retrieve a ResumableFile object from the file list by its unique identifier.\r\n   */\r\n  getFromUniqueIdentifier(uniqueIdentifier: string): ResumableFile {\r\n    return this.files.find((file) => file.uniqueIdentifier === uniqueIdentifier);\r\n  };\r\n\r\n  /**\r\n   * Get the combined size of all files for the upload\r\n   */\r\n  getSize(): number {\r\n    return this.files.reduce((accumulator, file) => accumulator + file.size, 0);\r\n  }\r\n\r\n  /**\r\n   * Call the event handler when a file is dropped on the drag-and-drop area\r\n   */\r\n  handleDropEvent(e: DragEvent): void {\r\n    this.onDrop(e);\r\n  }\r\n  /**\r\n   * Call the event handler when the provided input element changes (i.e. receives one or multiple files.\r\n   */\r\n  handleChangeEvent(e: InputEvent): void {\r\n    this.appendFilesFromFileList(Array.from((e.target as HTMLInputElement).files), e);\r\n    (e.target as HTMLInputElement).value = '';\r\n  }\r\n\r\n  /**\r\n   * Check whether the upload is completed, i.e. if all files were uploaded successfully.\r\n   */\r\n  checkUploadComplete(): void {\r\n    let uploadCompleted = this.files.every((file) => file.isComplete);\r\n    if (uploadCompleted) {\r\n      // All chunks have been uploaded, complete\r\n      this.fire('complete');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Event Handlers: This section should only include methods that are used to\r\n   * handle events coming from the files or chunks.\r\n   */\r\n\r\n  /**\r\n   * The event handler when a chunk was uploaded successfully\r\n   */\r\n  private handleChunkSuccess(): void {\r\n    this.uploadNextChunk();\r\n  }\r\n\r\n  /**\r\n   * The event handler when a chunk was uploaded successfully\r\n   */\r\n  private handleChunkError(): void {\r\n    this.uploadNextChunk();\r\n  }\r\n\r\n  /**\r\n   * The event handler when an error occurred during the upload of a chunk\r\n   */\r\n  private handleChunkCancel(): void {\r\n    this.uploadNextChunk();\r\n  }\r\n\r\n  /**\r\n   * The event handler when an error occurred during the upload of a file\r\n   */\r\n  private handleFileError(args: any[]): void {\r\n    this.fire('error', args[1], args[0]);\r\n  }\r\n\r\n  /**\r\n   * The event handler when all chunks from a file were uploaded successfully\r\n   */\r\n  private handleFileSuccess(args: any[]): void {\r\n    this.fire('fileSuccess', ...args);\r\n    this.checkUploadComplete();\r\n  }\r\n\r\n  /**\r\n   * The event handler when a file progress event was received\r\n   */\r\n  private handleFileProgress(): void {\r\n    this.fire('progress');\r\n  }\r\n\r\n  /**\r\n   * The event handler when the upload of a file was canceled\r\n   */\r\n  private handleFileCancel(args: any[]): void {\r\n    this.removeFile(args[0])\r\n  }\r\n\r\n  /**\r\n   * The event handler, when the retry of a file was initiated\r\n   */\r\n  private handleFileRetry(): void {\r\n    this.upload();\r\n  }\r\n}\r\n"],"names":["root","factory","exports","module","define","amd","this","ResumableChunk","constructor","fileObj","offset","options","super","lastProgressCallback","Date","tested","retries","pendingRetry","isMarkedComplete","loaded","xhr","chunkSize","forceChunkSize","fileParameterName","chunkNumberParameterName","chunkSizeParameterName","currentChunkSizeParameterName","totalSizeParameterName","typeParameterName","identifierParameterName","fileNameParameterName","relativePathParameterName","totalChunksParameterName","throttleProgressCallbacks","query","headers","method","uploadMethod","testMethod","parameterNamespace","testChunks","maxChunkRetries","chunkRetryInterval","undefined","permanentErrors","withCredentials","xhrTimeout","chunkFormat","setChunkTypeFromFile","target","testTarget","setInstanceProperties","fileObjSize","size","fileObjType","file","type","startByte","endByte","Math","min","Object","assign","setCustomHeaders","customHeaders","Function","header","hasOwnProperty","setRequestHeader","customQuery","uniqueIdentifier","fileName","relativePath","chunks","length","readyState","status","includes","abort","getTarget","requestType","formattedQuery","test","XMLHttpRequest","testHandler","fire","message","send","addEventListener","open","timeout","upload","e","now","getTime","doneHandler","retryInterval","setTimeout","bytes","slice","data","FormData","queryKey","append","fr","FileReader","onload","result","readAsDataURL","responseText","progress","relative","factor","markComplete","registeredEventHandlers","on","event","callback","toLowerCase","push","args","executeEventCallback","forEach","ResumableFile","_prevProgress","isPaused","opts","getFileNameFromFile","webkitRelativePath","_error","bootstrap","abortCount","chunk","cancel","retry","firedRetry","progressHandler","retryHandler","successHandler","isComplete","errorHandler","round","ceil","floor","maxOffset","max","ret","error","some","markChunksCompleted","chunkNumber","num","stopPropagation","preventDefault","name","replace","array","Array","isArray","reduce","a","b","concat","flattenDeep","errorCallback","seen","Set","filter","item","k","has","add","toFixed","sendTarget","params","separator","indexOf","joinedParams","entries","map","key","value","encodeURIComponent","join","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","Resumable","files","validators","clearInput","dragOverClass","fileTypes","fileTypeErrorCallback","alert","_generateUniqueIdentifier","maxFileSizeErrorCallback","formatSize","maxFileSize","maxFilesErrorCallback","maxFiles","minFileSize","minFileSizeErrorCallback","prioritizeFirstAndLastChunk","fileValidationErrorCallback","simultaneousUploads","checkSupport","support","File","Blob","FileList","prototype","Error","path","FileSystemFileEntry","Promise","resolve","reject","FileSystemDirectoryEntry","processDirectory","console","warn","entry","webkitGetAsEntry","getAsFile","directory","dirReader","createReader","allEntries","readEntries","async","mapItemToFile","all","currentTarget","classList","remove","stopEvent","items","dataTransfer","from","promises","mapDragItemToFile","appendFilesFromFileList","onDragLeave","onDragOverEnter","dt","types","dropEffect","effectAllowed","validationPromises","uniqBy","addedFile","fileType","fileExtension","split","pop","substring","results","_v","index","fileList","removeFile","filesWithUniqueIdentifiers","generateUniqueIdentifier","validatedFiles","validateFiles","skippedFiles","f","handleChunkSuccess","handleChunkError","handleChunkCancel","handleFileProgress","handleFileError","handleFileSuccess","handleFileCancel","handleFileRetry","uploadNextChunk","assignBrowse","domNodes","isDirectory","HTMLInputElement","domNode","input","tagName","document","createElement","setAttribute","style","display","opacity","focus","click","appendChild","removeAttribute","match","eventTarget","assignDrop","HTMLElement","bind","onDrop","unAssignDrop","removeEventListener","isUploading","pause","i","totalDone","accumulator","totalSize","getSize","addFile","addFiles","addFileValidator","validator","splice","getFromUniqueIdentifier","find","handleDropEvent","handleChangeEvent","checkUploadComplete","every"],"sourceRoot":""}